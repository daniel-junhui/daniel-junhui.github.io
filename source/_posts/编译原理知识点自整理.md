---
title: 编译原理知识点自整理
date: 2020-10-29 17:04:11
tags:
- 编译原理
- flex-bison
top_img: false
cover: /img/cover.jpg
katex: true
---

## 文法和语言

### 字母表和符号串
1. 字母表是非空元素的**集合**。用$\Sigma$表示
2. 字母表中的元素称为**符号**或者**字符**。
3. 符号所形成的有穷有序序列称为**符号串**。
4. $\epsilon$记为空符号串。

$$
x=y
$$

### 符号串的形式运算
1. 若$x$和$y$是符号串，则$xy$记为把$y$写在$x$后面形成的符号串。
2. **符号串的集合**的乘积定义为集合的笛卡儿积。
3. 符号串整数幂运算定义为多次乘积。特别地，$x^{0}=\epsilon$。
4. 符号串集合的幂运算定义为多次笛卡儿积。特别地，$A^{0}=\left\{\epsilon\right\}$。
5. 符号串集合$a$的闭包定义为

$$
A^{+}=A^{1}\cup A^{2} \cup ...\\
A^{*}=A^{0}\cup A^{1} \cup ...
$$

### 形式语言
1. 符号串的集合是形式语言。
2. 形式语言不考虑语义。
3. 当语言是有穷集合时，用枚举方法表示。
4. 当语言是无穷集合时，用**文法**表示语言。

### 文法
#### 文法的规则
1. 产生式（规则）是一个符号与一个符号串形成的有序对。写作$A\rightarrow\beta$。意为左部符号用右部的符号串定义。
2. 一组规则规定了一个语言的语法结构。
3. 符号分两类：terminal符号和nonterminal符号。terminal符号定义为出现在规则左部、能派生出符号或者符号串的符号。

#### 文法
文法是规则的非空有穷集合，表示为四元组$G=\left(V_{N},V_{T},P,S\right)$。
其中$V_{N}$是nonterminal符号，$V_{T}$是terminal符号，$P$是规则集合，$S$是文法的开始符号。

### 语言
#### 推导
##### 直接推导
令$G$是一个文法。

仅当$A\rightarrow\alpha$是$G$的一个规则且$x,y \in \left(V_{N} \cup V_{T}\right)^{*}$时，我们可以说：$xAy\Rightarrow x\alpha y$。即，从左直接推导到右，仅使用一次规则。

#### 推导的定义
若存在一个直接推导序列：
$$
\alpha_{0}\Rightarrow \alpha_{1}\Rightarrow \alpha_{2}\Rightarrow ... \alpha_{n}
$$
则说这个序列是从$\alpha_{0}$到$\alpha_{n}$、长度为$n$的推导，记之为：$\alpha_{0} \stackrel{+}{\Rightarrow} \alpha_{n}$。长度大于等于1。

#### 广义推导
广义推导记为$\alpha_{0} \stackrel{*}{\Rightarrow} \alpha_{n}$。与之前的推导相比，多了一个**推出自己**的行为。长度大于等于0。

#### 句型
设有文法$G\left[S\right]$，若$S \stackrel{*}{\Rightarrow}x$，且$x \in (V_{N}\cup V_{T})^{*}$时，称符号串$x$为文法的**句型**。

#### 句子
设有文法$G\left[S\right]$，若$S \stackrel{*}{\Rightarrow}x$，且$x \in  V_{T}^{*}$时，称符号串$x$为文法的**句子**。

#### 语言
文法$G\left[S\right]$所产生的所有**句子**的集合称为文法定义的**语言**，记为$L\left(G\left[S\right]\right)$

1. 文法给定后，语言就确定了。
2. $L\left(G\left[S\right]\right)$是$V_{T}^{*}$的**子集**。

### 规范推导和规范规约
很明显，同一个句子、句型是可以通过不同的推导序列推导出的，因为可以选择不同的nonterminal次序。

最左（最右）推导：推导序列中每一步直接推导都是对左部中最左（最右）的nonterminal进行替换。

最右推导也叫**规范推导**，用规范推导推导出的句型称为**规范句型**。

规范推导的逆过程，被称为**最左规约**，也叫做**规范规约**。

### 规则递归
在规则的左部和右部具有相同的nonterminal时，称为递归规则。

- 若有$A\rightarrow A...$，称为规则左递归。
- 若有$A\rightarrow ...A$，称为规则右递归。
- 若有$A\rightarrow ...A...$，称为规则递归。

### 文法递归
对于文法，若存在一个nonterminal和一个推导，和规则递归相似时，称为文法递归。

- 若有$A\Rightarrow A...$，称为文法左递归。
- 若有$A\Rightarrow ...A$，称为文法右递归。
- 若有$A\Rightarrow ...A...$，称为文法递归。

### 短语、直接短语

令$G$是一个文法，$S$是文法的开始符号，而$\alpha \beta \sigma$是其一个句型。如果有：
$$
S \stackrel{*}{\Rightarrow}\alpha \beta \sigma且A\stackrel{+}{\Rightarrow} \beta
$$
则称：$\beta$是**相对于nonterminal $A$**的**句型$\alpha \beta \sigma$**的短语。

特别地，如果$S \stackrel{*}{\Rightarrow}\alpha \beta \sigma且A\Rightarrow \beta$，则称为**直接短语**。

### 句柄
一个句型的**最左直接短语**称为该句型的**句柄**。
1. 句柄是直接短语，由于推导左部是nonterminal，所以句柄不仅在直接推导右部，也在一则规则右部。
2. 最左。

### 语法树
#### 语法树的生成
语法树是句型的推导过程的一种**图形表示**。设存在文法$G=\left(V_{N},V_{T},P,S\right)$，对其任何句型都能构造满足下列要求的语法树。
1. 每个结点都有一个标记，标记是$ V_{N}\cup V_{T}\cup\left\{\epsilon\right\} $中的一个符号。
2. root结点的标记是开始符号$S$。
3. 若某一个结点至少有一个子结点，则其标记一定是**nonterminal**。
4. 若某个结点$A$有$k$个子结点，其标记分别为$A_{1},...,A_{k}$，则一定存在规则$A \rightarrow A_{i}, i=1...k$。

#### 子树和简单子树
由于即使是同一课语法树，也有可能对应于多种不同的推导过程。而引入子树和简单子树，则是为了找到**句型短语和句柄**。
##### 子树
任一非root结点和其所有结点的分支就是子树。

##### 简单子树
只具有**单层分支**的子树称为简单子树。

1. 对于该语法树对应的**句型**，子树的末端结点形成的符号串是**相对于子树root的短语**。
2. 简单子树的末端结点形成的符号串是相对于简单子树root的**直接短语**。
3. 最左简单子树的末端结点形成的符号串是**句柄**。

### 文法的二义性
当存在不同的最左（最右）推导时，产生的语法树也不同。

文法的句型是否只对迎着唯一的一颗语法树？
是否只有唯一的最左（最右）推导？

若某个句子对应两颗不同的语法树，则说该文法是**二义性**的。
#### 二义性的消除
1. 不改变语法规则，加一些语法的非形式规定。比如运算符的优先级。
2. 构造一个等价的无二义性的文法。

**不存在一个算法，能在有限的步骤内判定一个文法是否为二义性的。**

### 文法和语言的分类
假设存在文法$G=\left(V_{N},V_{T},P,S\right)$。
#### 0型文法（无限制文法）
若文法中每条规则$\alpha \rightarrow \beta$都满足下列要求：
1. $\alpha \in \left(V_{N} \cup V_{T}\right)^{*}$且至少包含一个nonterminal。
2. $\beta \in \left(V_{N} \cup V_{T}\right)^{*}$。

则该文法是0型文法，其描述的语言为0型语言。

0型语言又称为无限制性语言。

#### 1型文法（上下文有关文法）
若文法中每条规则的形式为：$\alpha A \beta \rightarrow \alpha u \beta$，满足：
1. $\alpha,\beta \in \left(V_{N} \cup V_{T}\right)^{*}$。
2. $u \in \left(V_{N} \cup V_{T}\right)^{+}$。

则该文法是1型文法，其描述的语言为1型语言。

因为在利用规则将$A$替换为$u$时，必须考虑其上下文环境（$\alpha, \beta$），且不允许替换为空字符串，因此也成为**上下文有关文法**。

#### 2型文法（上下文无关文法）
若文法中每一条规则的形式为$A \rightarrow \beta$，且满足：
1. $A \in V_{N}$。
2. $\beta \in \left(V_{N} \cup V_{T}\right)^{*}$。

编译原理课程所主要研究对象为上下文无关文法。

#### 3型文法（正规文法）
- 若每条规则的形式为$A\rightarrow \alpha B$或者$A \rightarrow \alpha$，其中$A,B \in V_{N}, \alpha \in V_{T}^{*}$，则称其为**右线性文法**。
- 若每条规则的形式为$A\rightarrow B \alpha$或者$A \rightarrow \alpha$，其中$A,B \in V_{N}, \alpha \in V_{T}^{*}$，则称其为**左线性文法**。

左、右线性文法都被称为3型文法、正规文法，其语言为正规语言。

从0型文法到3型文法，对规则的限制逐渐增加，每一种文法都是前一种文法的**子文法**。

## 词法分析和有穷自动机

### 词法分析程序
词法分析程序是语法分析程序的一个子程序（子类），每当语法分析程序需要一个单词符号时，就调用词法分析程序的API，让词法分析程序从输入的String中，识别出一个具有独立意义的token。

### Token

#### token简介
词法分析程序的输入是String形式的**source program**，输出tokens。这样的过程叫做tokenization。

token是语言中具有独立意义的最小语法单位。一般分为5种：

1. keyword	比如：if, else, while, do等
2. identifier	比如：对象名、函数名等
3. constant	包括stringConstant、intConstant、floatConstant和boolConstant
4. operator	包括加减乘除等
5. punctuator	包括分号，逗号，括号等

####  输出token的形式
以以下形式输出token：
$$
\left(tokenType,\ tokenValue\right)
$$
1. 每一个tokenType对应一个整数编码。
2. 当一个tokenType里只含有一种value时，该整数编码就完全代表了value，因此value可以省略。

#### token的两种定义

##### 正规文法（左线型文法或者右线性文法）
正规文法定义token易于识别，以identifier举例：
$$
<identifier> \rightarrow l|<identifier>l|<identifier>d \\
l:\ a\sim z \  or\  A \sim Z\\
d:\ 0\sim 9
$$

##### 正规式 regular expression
设存在字母表$\Sigma = \left \{a_{1}, a_{2},...,a_{n}\right\}$，在其上的正规式与正规式表示的正规集用以下（递归）规则定义：

1. $\varnothing$是$\Sigma$上的正规式，表示的正规集也是$\varnothing$。
2. $\epsilon$是$\Sigma$上的正规式，表示的正规集是$\left\{\epsilon\right\}$。
3. $a_{i}$是$\Sigma$上的正规式，表示的正规集是$\left\{a_{i}\right\}$。
4. 若$e_{1}$和$e_{2}$都是$\Sigma$上的正规式，所表示的正规集为$L\left(e_{1}\right)$和$L\left(e_{2}\right)$，那么
	1. $e_{1}|e_{2}$也是正规式，$L\left(e_{1}|e_{2}\right)=L\left(e_{1}\right) \cup L\left(e_{2}\right)$。
	2. $e_{1}e_{2}$也是正规式，$L\left(e_{1}e_{2}\right)=L\left(e_{1}\right)  L\left(e_{2}\right)$。
	3. $\left(e_{1}\right)^{*}$也是正规式，$L\left(\left(e_{1}\right)^{*}\right)=\left(L\left(e_{1}\right)\right)^{*}$。

##### 正规式的一些性质
1. $|$运算的交换律	$A|B=B|A$
2. $|$运算的结合律	$A|\left(B|C\right)=\left(A|B\right)|C$
3. $\cdot$运算的结合律	$A\left(BC\right)=\left(AB\right)C$
4. 分配律	$A\left(B|C\right)=AB|AC$
5. $A\epsilon|\epsilon A=A$
6. $\left(A^{*}\right)^{*}=A^{*}$

#### 正规文法与正规式的相互转换

##### 正规文法转正规式
1. 将正规文法中的每个nonterminal表示成关于它的正规式方程，获得一个**联立方程组**。
2. 终结规则：
$$
if\ \  x=\alpha x|\beta,\ x=\alpha^{*}\beta \\
if\ \  x=x\alpha|\beta,\ x=\beta\alpha^{*}
$$
3. 用终结规则、分配律、交换律和结合律求解即可。

一个（不太）简单的例子
$$
正规文法\ G：\\
Z\rightarrow 0A\\
A\rightarrow 0A|0B \\
B\rightarrow 1A|\epsilon
$$
由第三式和第二式，有
$$
A=0A|01A|0 \\
A=(0|01)A|0
$$
所以
$$
A=(0|01)^{*}0 \\
Z=0(0|01)^{*}0
$$

##### 正规式转换正规文法
假设存在字母表$\Sigma$和正规式，需要转换为正规文法$G=\left(V_{N},V_{T},P,S\right)$。

1. $V_{T}=\Sigma$。
2. 对原始正规式$R$选择一个nonterminal $Z$，生成规则$Z\rightarrow R$，令$S=Z$。
3. 若存在形如$A\rightarrow ab$的规则，转换为$A\rightarrow \alpha B$和$B\rightarrow b$。
4. 若存在形如$A\rightarrow a^{*}b$的规则，转换为$A \rightarrow aA|b$。
5. 重复3和4，直到没得转换。

### 有穷自动机
有穷自动机是具有**离散输入**和**输出系统**的一种抽象数学模型，分为确定有穷自动机和非确定有穷自动机，两者都能准确识别正规集。

#### 确定有穷自动机 DFA
一个DFA是一个五元组$M=\left(Q,\Sigma,f,S,Z\right)$，其中
1. $Q$是一个有穷状态集合，集合中每一个元素是一个**状态**；
2. $\Sigma$是一个有穷输入字母表，表中每个元素称为一个**输入字符**；
3. $f$是一个$Q \times \Sigma$到$Q$的单射，即$\left(q_{i},a\right)\stackrel{f}{\rightarrow} q_{j}，其中q_{i},q_{j} \in Q,a \in \Sigma$；
4. $S \in Q$是唯一的一个初态；
5. $Z \subseteq Q$是终态集合。

当前状态为$q_{i}$、输入字符为$a$时，自动机就转换到下一个状态$q_{j}$。此时$q_{j}$称为$q_{i}$的一个后继状态。

单射的意义：任意一个状态与输入的二元组都**唯一**确定了下一个状态。

一个DFA可以用一个矩阵表示，也可以用图表示。

- 用矩阵表示时，行表示状态，列表示输入符号，矩阵元素表示$f\left(q,a\right)$
- 用图表示时，假设有m个状态和n个输入字符，则图含有m个状态结，每个状态结**最多**有n条**箭弧**与别的状态结连接。整个图含有**唯一**一个初态结和多个终态结。
- 对于$\Sigma^{*}$中的任意符号串$\beta$，若存在一条路从初态结到终态结，且这条路上所有的符号连成的符号串等于$\beta$，则称：**$\beta$被DFA $M$所识别**。
- 若$M$的初态结也是终态结，那么$\epsilon$也可以被识别。
- DFA $M$可识别的符号串的全体记为$L\left(M\right)$。

#### 非确定有穷自动机 NFA
一个NFA也是一个五元组$M=\left(Q,\Sigma,f,S,Z\right)$，其中
1. $Q,\Sigma,Z$与DFA中相同；
2. $f$不再是单射，而是一个**多值**函数，映射出一个集合；
3. $f\left(q_{i},a\right)=\left\{某些状态的集合\right\}$；
4. $S \subset Q$是**非空初态集**。

- NFA允许状态图中，边的标记为$\epsilon$。
- 