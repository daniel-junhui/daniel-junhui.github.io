---
title: 两道有点麻烦的算法题
top_img: false
cover: /img/CSAPP.jpeg
date: 2020-11-05 10:13:51
tags:
- CSAPP
- C Programming
katex: true
---

昨天做ICS quiz 1的时候有两道题没做出来，在这里记一下。

## 不用control flow logics（循环、分支）把输入的32-bit 整数的偶数bit位的顺序颠倒，再返回。

用分治就好了

```C
uint32_t reverseEvenBits(uint32_t x) {
    int odd_bits = x & 0xaaaaaaaa;
    x = x & 0x55555555;
    int mask_16 = 0x0000ffff;
    x = ((x >> 16) & mask_16) | ((x & mask_16) << 16);
    int mask_8 = 0x00ff00ff;
    x = ((x >> 8) & mask_8) | ((x & mask_8) << 8);
    int mask_4 = 0x0f0f0f0f;
    x = ((x >> 4) & mask_4) | ((x & mask_4) << 4);
    int mask_2 = 0x33333333;
    x = ((x >> 2) & mask_2) | ((x & mask_2) << 2);
    
    return odd_bits | x;
}
```
## 一个数组，除了唯一的一个元素只出现一次以外，其他元素都出现三次，找出这个元素。
**只能用bit operations，而且不能用左右移，最多用4个local variables。**

这是一道很珍贵的题，我想把它好好记录一下。

把这道题简化，对于一个单bit数组，数组中的1要么出现$3n$次和$3n+1$次。

在遍历的过程中，1的出现个数要么是$3n$、$3n+1$和$3n+2$次。3个状态则需要2个bit来表示，那我只需要引入两个单bit变量`high`和`low`就好了，构造状态表：

| 状态 (high+low) | 1出现的次数 |
| --------------- | ----------- |
| 00              | 3n          |
| 01              | 3n+1        |
| 10              | 3n+2        |

最终，只需要把low给提出来，就知道只出现1次的是1还是0了。可以写出状态转移的真值表：

|   Before   |      |      | After |      |
| ---- | ---- | ---- | ---- | ---- |
| High | Low | Input | High | Low |
| 0 | 0 | 0 | 0 | 0 |
| 0 | 1 | 0 | 0 | 1 |
| 1 | 0 | 0 | 1 | 0 |
| 0 | 0 | 1 | 0 | 1 |
| 0 | 1 | 1 | 1 | 0 |
| 1 | 0 | 1 | 0 | 0 |

表达式也可以用布尔代数写出来

$$
high=high \land \lnot low \land \lnot input \lor \lnot high \land low \land input\\
low = \lnot hight \land \left(low \oplus input \right)
$$

**但事实上，以上所说的所有事情，都可以完全扩展到32位，不管是变量`high`还是`low`**。因为可以把一个32位的int看成32个独立的bit，并且并行地去处理每个bit。所以答案就出来了。


```C
int singleNumber(int *nums, int numSize) {
    int low = 0, high = 0;
    int orig_low;
    for (int i = 0; i < numSize; i++) {
        orig_low = low;
        low = ~high & (low ^ nums[i]);
        high = (high & ~orig_low & ~nums[i]) | (~high & orig_low &nums[i]);
    }
    return low;
}
```