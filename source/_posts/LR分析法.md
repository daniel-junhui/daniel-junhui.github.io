---
title: LR分析法
top_img: false
cover: /img/compiler.jpg
date: 2020-11-30 13:05:40
tags:
- 编译原理
katex: true
---

LR分析法是比较麻烦的一种自底向上的分析方法。整体思路在于**寻找句柄**和**最左规约**。

在分析字符串时，将待分析字符串从左至右push到stack中，一旦出现句柄，就规约。需要构造一个**LR(0)分析表**

## LR(0)分析法

### 一个例子
文法$G[S]$：
$$
\begin{aligned}
&E\rightarrow aA \\
&E\rightarrow bB\\
&A\rightarrow cA\\
&A\rightarrow d\\
&B\rightarrow cB\\
&B\rightarrow d
\end{aligned}
$$
把该文法托广：

$$
\begin{aligned}
&0.\;S^{'}\rightarrow E\\
&1.\;E\rightarrow aA \\
&2.\;E\rightarrow bB\\
&3.\;A\rightarrow cA\\
&4.\;A\rightarrow d\\
&5.\;B\rightarrow cB\\
&6.\;B\rightarrow d
\end{aligned}
$$

推出识别**活前缀**的DFA：
{% img "/img/com.png" %}

得到DFA后由此得到LR(0)分析表：

| 状态 | a     | b     | c     | d     | $     | E    | A    | B    |
| ---- | ----- | ----- | ----- | ----- | ----- | ---- | ---- | ---- |
| 0    | $S_1$ | $S_2$ |       |       |       | $3$  |      |      |
| 1    |       |       | $S_4$ | $S_5$ |       |      | $6$  |      |
| 2    |       |       | $S_7$ | $S_8$ |       |      |      | $9$  |
| 3    |       |       |       |       | $acc$ |      |      |      |
| 4    |       |       | $S_4$ | $S_5$ |       |      | $10$ |      |
| 5    | $r_4$ | $r_4$ | $r_4$ | $r_4$ | $r_4$ |      |      |      |
| 6    | $r_1$ | $r_1$ | $r_1$ | $r_1$ | $r_1$ |      |      |      |
| 7    |       |       | $S_7$ | $S_8$ |       |      |      | $11$ |
| 8    | $r_6$ | $r_6$ | $r_6$ | $r_6$ | $r_6$ |      |      |      |
| 9    | $r_2$ | $r_2$ | $r_2$ | $r_2$ | $r_2$ |      |      |      |
| 10   | $r_3$ | $r_3$ | $r_3$ | $r_3$ | $r_3$ |      |      |      |
| 11   | $r_5$ | $r_5$ | $r_5$ | $r_5$ | $r_5$ |      |      |      |

在得到分析表后，对于任意字符串，从**状态0**开始，启动自动机。对于读入的下一个字符$\alpha$与当前的状态，定位到分析表中的元素。
- 如果该元素是$S_{j}$，则将这个字符push to stack，并且从当前状态转换到状态$j$。
- 如果该元素是$r_{j}$，则根据（扩展）文法中第$j$条规则，从stack中pop出**与该规则右部字符串长度相同个数的字符**；然后把规则左部的**非终结字符**push to stack，如果该非终结字符为$A$，则当前状态转换到分析表中**当前状态**和$A$所定位到的状态数。
- 如果遇到分析表中的空值，则抛出一个error，分析出错。
- 如果遇到$acc$，分析结束。

LR(0)的分析逻辑还算比较简单，但仍然有几个问题未解决：
1. 文法的活前缀是什么？
2. 如何得到文法活前缀的DFA？
3. 如何由DFA得到分析表？


### 文法的活前缀
#### 前缀
字符串的前缀是指字符串的任意首部。比如，$abc$的前缀有：$\epsilon,\;a,\;ab,\;abc$。

#### 规范句型的活前缀
>回溯学习：规范句型是什么?
>用规范推导所推导出的句型称为规范句型。
>回溯学习：什么是规范推导？
>规范推导就是最右推导，这与自底向上分析法中**最左规约**是相对应的。
>

而规范句型的活前缀，是指规范句型中、**不包含句柄右边任何符号**的前缀。
>回溯学习：句柄是什么？
>句柄是一个句型的最左直接短语。
>
>那直接短语又是什么？
>
>假设$\alpha \beta \delta$是文法$G$的一个句型，如果有
>$$
>S{\stackrel{*}{\Rightarrow}}\alpha A \delta \land A \Rightarrow \beta
>$$
>则称$\beta$是相对于非终结字符$A$的、句型$\alpha \beta \delta$的一个直接短语。


从LR分析法的定义也能看出，当所分析的输入串没有语法错误时，每时每刻的stack里的符号与剩余的输入符号串都能形成一个规范句型。
并且，如果stack中一旦存在**句柄**，那它立马就会被规约了，直到没有句柄为止。

那就很明显了，实际上，stack中的字符就是**规范句型的活前缀**。那么，问题就转化为能不能将stack中的字符串识别为一个规范句型活前缀了。

#### LR(0)项目
由前文的活前缀定义，在一个规范句型的活前缀中，绝不含有句柄右边的任何符号，但仍然有可能含有或不含句柄的部分符号。因此会有三种情形：
1. 活前缀中已经含有句柄的全部字符。也就是说，某一规则$A \rightarrow \alpha$的右部已经出现在了stack顶端，此时应该进行规约。
2. 活前缀中只含有句柄的一部分字符。假如说存在一个规则$A \rightarrow \alpha_1 \alpha_2$，那只有$\alpha_1$在stack顶端，需要继续输入字符。
3. 活前缀中完全没有任何句柄的符号，需要输入字符。