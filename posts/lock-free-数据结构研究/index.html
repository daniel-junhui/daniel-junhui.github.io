<!DOCTYPE html>
<html lang="en-us">
  <head>
    <title>Lock-free 数据结构研究 | Junhui Zhu</title>

    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">    
<meta name="viewport" content="width=device-width,minimum-scale=1">
<meta name="description" content="精读文章 http://erdani.org/publications/cuj-2004-12.pdf and https://erdani.org/publications/cuj-2004-10.pdf">
<meta name="generator" content="Hugo 0.82.1" />


  <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">


<link rel="stylesheet" href="/css/style.css">



<link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon" />







  </head>

  <body>
    <nav class="navigation">
	
		<a href="/"> <span class="arrow">←</span>Home</a>
	
	<a href="/posts">Archive</a>
	<a href="/tags">Tags</a>
	<a href="/about">About</a>

	
		<a href="https://www.zhihu.com/people/zhu-jun-hui-40-47">Zhihu</a>
	

	
	  <a class="button" href="https://jhzhu.xyz/index.xml">Subscribe</a>
	
</nav>


    <main class="main">
      

<section id="single">
    <h1 class="title">Lock-free 数据结构研究</h1>

    <div class="tip">
        <time datetime="2023-01-16 00:00:00 &#43;0000 UTC">Jan 16, 2023</time>
        <span class="split">
          ·
        </span>
        <span>
          1000 words
        </span>
        <span class="split">
          ·
        </span>
        <span>
          2 minute read
        </span>
    </div>

    
    
        
  
    <aside class="toc">
      <details>
          <summary>Table of Contents
          </summary>
          <div>
              <nav id="TableOfContents">
  <ul>
    <li><a href="#lock-free-still-needs-atomic-operations">Lock free still needs atomic operations</a></li>
    <li><a href="#wait-free-and-lock-free">Wait-free and lock-free</a></li>
    <li><a href="#a-lock-free-map">A Lock-free Map</a>
      <ul>
        <li><a href="#a-lockful-implementation">A lockful implementation</a></li>
        <li><a href="#the-first-lock-free-version">The first lock-free version</a></li>
        <li><a href="#try-with-reference-counting">Try with reference-counting</a></li>
        <li><a href="#next-optimization">Next optimization</a></li>
      </ul>
    </li>
  </ul>
</nav>
          </div>
      </details>
    </aside>
  


    


    <div class="content">
      <p>精读文章 <a href="http://erdani.org/publications/cuj-2004-12.pdf">http://erdani.org/publications/cuj-2004-12.pdf</a> and <a href="https://erdani.org/publications/cuj-2004-10.pdf">https://erdani.org/publications/cuj-2004-10.pdf</a></p>
<h2 id="lock-free-still-needs-atomic-operations">Lock free still needs atomic operations <a href="#lock-free-still-needs-atomic-operations" class="anchor">🔗</a></h2><p>There is a minimal set of atomic primitives that would allow implementing any lock-free algorithm. There is a paper &ldquo;Wait-Free Synchronization&rdquo; discussing about it. There are some interesting summaries:</p>
<ul>
<li><code>test-and-set</code>, <code>swap</code>, <code>fetch-and-add</code>, <code>atomic queues</code> are insufficient for properly synchronizing more than <strong>two</strong> threads.</li>
<li>Some simple constructs are enough for lock-free algorithm for <strong>any</strong> number of threads.</li>
</ul>
<p>The simplest primitive is <code>compare-and-swap</code>:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#a2f;font-weight:bold">template</span> <span style="color:#666">&lt;</span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">T</span><span style="color:#666">&gt;</span>
<span style="color:#0b0;font-weight:bold">bool</span> CAS(T<span style="color:#666">*</span> addr, T exp, T val) {
  <span style="color:#a2f;font-weight:bold">if</span> (<span style="color:#666">*</span>addr <span style="color:#666">==</span> exp) {
    <span style="color:#666">*</span>addr <span style="color:#666">=</span> val;
    <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f">true</span>;
  }
    <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f">false</span>;
}
</code></pre></div><p>CAS has three parameters: <code>addr</code>, <code>exp</code> and <code>val</code>. It compares the value pointed by <code>addr</code> with <code>exp</code>, if they are equal, sets the memory pointed by <code>addr</code> to a new value and returns <code>true</code>, otherwise returns <code>false</code> and does nothing.</p>
<h2 id="wait-free-and-lock-free">Wait-free and lock-free <a href="#wait-free-and-lock-free" class="anchor">🔗</a></h2><ul>
<li>Wait-free: a procedure that can complete in a finite number of steps.</li>
<li>Lock-free: a procedure guarantees progress of at least one of the threads executing the procedure. <strong>在每一步，至少有一个 thread 在前进</strong>。</li>
</ul>
<p>Lock-based programs cannot provide wait-free and lock-free guarantees (deadlock or a thread is sleeping while holding the lock). The metaphor of livelock is very interesting in the paper: Two dudes in the hallway trying to go past one another but end up doing that social dance of swinging left and right in synchronicity.</p>
<p>Some advantages of wait-free and lock-free algs:</p>
<ol>
<li>A thread forcefully killed will not delay others.</li>
<li>Lock-free routines can freely interleave execution, not like <code>malloc</code> cannot be called in signal handlers (because there is a heap lock).</li>
<li>Immune to priority inversion.</li>
</ol>
<h2 id="a-lock-free-map">A Lock-free Map <a href="#a-lock-free-map" class="anchor">🔗</a></h2><p>WRRM: Write Rarely Read Many, the scenes including <code>factories</code>, <code>observer design pattern</code>, etc.</p>
<p><code>assoc_vector</code> is used to implement it with trading update speed for lookup seed. Whatever is used, the interface is a <code>Map&lt;Key, Value&gt;</code>. And no <code>iteration</code> provided.</p>
<h3 id="a-lockful-implementation">A lockful implementation <a href="#a-lockful-implementation" class="anchor">🔗</a></h3><div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#a2f;font-weight:bold">template</span><span style="color:#666">&lt;</span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Key</span>, <span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Value</span><span style="color:#666">&gt;</span>
<span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">WRRMMap</span> {
  Mutex mutex_;
  Map<span style="color:#666">&lt;</span>Key, Value<span style="color:#666">&gt;</span> map_;

<span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
  Value Lookup(<span style="color:#a2f;font-weight:bold">const</span> Key<span style="color:#666">&amp;</span> key) {
    Lock <span style="color:#00a000">lock</span>(mutex_);
    <span style="color:#a2f;font-weight:bold">return</span> map_[key];
  }

  <span style="color:#0b0;font-weight:bold">void</span> <span style="color:#00a000">Update</span>(<span style="color:#a2f;font-weight:bold">const</span> Key<span style="color:#666">&amp;</span> key, <span style="color:#a2f;font-weight:bold">const</span> Value<span style="color:#666">&amp;</span> value) {
    Lock lock(mutex_);
    map_.insert(key, value);
  }
}
</code></pre></div><p>It is really a bad implmentation because parallel lookups does not need locks. (As long as there is no updates currently)</p>
<h3 id="the-first-lock-free-version">The first lock-free version <a href="#the-first-lock-free-version" class="anchor">🔗</a></h3><ul>
<li>Reads does not need lock.</li>
<li>Store the <code>map_</code> as a pointer.</li>
<li>Updates make a copy of the original map and use <code>CAS</code> to replace it.</li>
</ul>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#a2f;font-weight:bold">template</span><span style="color:#666">&lt;</span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Key</span>, <span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Value</span><span style="color:#666">&gt;</span>
<span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">WRRMMap</span> {
  Map<span style="color:#666">&lt;</span>Key, Value<span style="color:#666">&gt;</span> <span style="color:#666">*</span>map_;

<span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
  Value Lookup(<span style="color:#a2f;font-weight:bold">const</span> Key<span style="color:#666">&amp;</span> key) {
    <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#666">*</span>map_[key];
  }

  <span style="color:#0b0;font-weight:bold">void</span> <span style="color:#00a000">Update</span>(<span style="color:#a2f;font-weight:bold">const</span> Key<span style="color:#666">&amp;</span> key, <span style="color:#a2f;font-weight:bold">const</span> Value<span style="color:#666">&amp;</span> value) {
    Map<span style="color:#666">&lt;</span>Key, Value<span style="color:#666">&gt;*</span> new_map <span style="color:#666">=</span> <span style="color:#a2f;font-weight:bold">nullptr</span>;
    <span style="color:#a2f;font-weight:bold">do</span> {
      Map<span style="color:#666">&lt;</span>Key, Value<span style="color:#666">&gt;*</span> old_map <span style="color:#666">=</span> map_;
      <span style="color:#a2f;font-weight:bold">if</span>(new_map) <span style="color:#a2f;font-weight:bold">delete</span> new_map;
      new_map <span style="color:#666">=</span> <span style="color:#a2f;font-weight:bold">new</span> Map<span style="color:#666">&lt;</span>Key, Value<span style="color:#666">&gt;</span>(old_map);
      new_map.insert(key, value);
    } <span style="color:#a2f;font-weight:bold">while</span> (<span style="color:#666">!</span>CAS(map_, old_map, new_map));

    <span style="color:#080;font-style:italic">// map_ is not deleted because it is possibly accessed by some thread via lookup
</span><span style="color:#080;font-style:italic"></span>  }
}
</code></pre></div><p>This map is globally wait-free, but the <code>Update</code> of a single thread is not wait-free. However, C++ does not have GC and the <code>map_</code> cannot be deleted before <code>Update</code> returns. <strong>Deterministic memory freeing is quite a fundamental problem in lock-free data structures</strong>.</p>
<h3 id="try-with-reference-counting">Try with reference-counting <a href="#try-with-reference-counting" class="anchor">🔗</a></h3><div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#a2f;font-weight:bold">template</span> <span style="color:#666">&lt;</span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Key</span>, <span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Value</span><span style="color:#666">&gt;</span>
  <span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">WRRMMap</span> {
    <span style="color:#a2f;font-weight:bold">using</span> Data <span style="color:#666">=</span> std<span style="color:#666">::</span>pair<span style="color:#666">&lt;</span>Map<span style="color:#666">&lt;</span>Key, Value<span style="color:#666">&gt;*</span>, <span style="color:#0b0;font-weight:bold">unsigned</span><span style="color:#666">&gt;</span>;
    Data<span style="color:#666">*</span> data_;
  ...
};
</code></pre></div><p>Then <code>Lookup</code> can increments <code>data-&gt;second</code> and decrements it after searching. If the rc hits 0, delete it. However, it is still not thread-safe.</p>
<p>But the rc of the old <code>map_</code> will go to zero at some time, because new lookups will use the new map. So one solution is to use a queue to store old <code>map_</code>s and let a thread to check rc and delete them in loop. However, if a lookup thread is delayed a lot so that the scavenger cannot delete that map, so it is not theoretically safe.</p>
<p>Another <a href="https://dl.acm.org/doi/proceedings/10.1145/383962" target="_blank" rel="noopener">solution</a> uses DCAS. DCAS is kind of a double-CAS:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#a2f;font-weight:bold">template</span> <span style="color:#666">&lt;</span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">T1</span>, <span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">T2</span><span style="color:#666">&gt;</span>
<span style="color:#0b0;font-weight:bold">bool</span> DCAS(T1<span style="color:#666">*</span> p1, T2<span style="color:#666">*</span> p2,
          T1 e1, T2 e2,
          T1 v1, T2 v2) {
  <span style="color:#a2f;font-weight:bold">if</span> (<span style="color:#666">*</span>p1 <span style="color:#666">==</span> e1 <span style="color:#666">&amp;&amp;</span> <span style="color:#666">*</span>p2 <span style="color:#666">==</span> e2) {
    <span style="color:#666">*</span>p1 <span style="color:#666">=</span> v1;
    <span style="color:#666">*</span>p2 <span style="color:#666">=</span> v2;
    <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f">true</span>;
  }
  <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f">false</span>;
}
</code></pre></div><p>The memories pointed by <code>p1</code> and <code>p2</code> will be replaced by <code>v1</code> and <code>v2</code> <strong>if and only if</strong> <code>*p1 == e1 &amp;&amp; *p2 == e2</code>.</p>
<h3 id="next-optimization">Next optimization <a href="#next-optimization" class="anchor">🔗</a></h3><p>CAS is still used, but a version supporting more than a pointer-length.</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#a2f;font-weight:bold">template</span> <span style="color:#666">&lt;</span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Key</span>, <span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Value</span><span style="color:#666">&gt;</span>
<span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">WRRMMap</span> {
  <span style="color:#a2f;font-weight:bold">using</span> Data <span style="color:#666">=</span> std<span style="color:#666">::</span>pair<span style="color:#666">&lt;</span>Map<span style="color:#666">&lt;</span>Key, Value<span style="color:#666">&gt;*</span>, <span style="color:#0b0;font-weight:bold">unsigned</span><span style="color:#666">&gt;</span>;
  Data data_;
<span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
  Value Lookup(<span style="color:#a2f;font-weight:bold">const</span> Key<span style="color:#666">&amp;</span> key) {
    Data old;
    Data fresh;
    <span style="color:#a2f;font-weight:bold">do</span> {
      old <span style="color:#666">=</span> data_;
      fresh <span style="color:#666">=</span> old;
      <span style="color:#666">++</span>fresh.second;
    } <span style="color:#a2f;font-weight:bold">while</span>(<span style="color:#666">!</span>CAS(<span style="color:#666">&amp;</span>data, old, fresh));

    Value temp <span style="color:#666">=</span> (<span style="color:#666">*</span>fresh.first)[k];
    <span style="color:#a2f;font-weight:bold">do</span> {
      old <span style="color:#666">=</span> data_;
      fresh <span style="color:#666">=</span> old;
      <span style="color:#666">--</span>fresh.second;
    } <span style="color:#a2f;font-weight:bold">while</span>(<span style="color:#666">!</span>CAS(<span style="color:#666">&amp;</span>data_, old, fresh));
    <span style="color:#a2f;font-weight:bold">return</span> temp;
  }

  <span style="color:#0b0;font-weight:bold">void</span> <span style="color:#00a000">Update</span>(<span style="color:#a2f;font-weight:bold">const</span> Key<span style="color:#666">&amp;</span> key, <span style="color:#a2f;font-weight:bold">const</span> Value<span style="color:#666">&amp;</span> value) {
    Data old;
    Data fresh;
    old.second <span style="color:#666">=</span> <span style="color:#666">1</span>;
    fresh.first <span style="color:#666">=</span> <span style="color:#a2f;font-weight:bold">nullptr</span>;
    fresh.second <span style="color:#666">=</span> <span style="color:#666">1</span>;
    Map<span style="color:#666">&lt;</span>Key, Value<span style="color:#666">&gt;*</span> last <span style="color:#666">=</span> <span style="color:#a2f;font-weight:bold">nullptr</span>;

    <span style="color:#a2f;font-weight:bold">do</span> {
      old.first <span style="color:#666">=</span> data_.first;
      <span style="color:#a2f;font-weight:bold">if</span>(last <span style="color:#666">!=</span> old.first) {
        <span style="color:#a2f;font-weight:bold">if</span>(fresh.first)
          <span style="color:#a2f;font-weight:bold">delete</span> fresh.first;
        fresh.first <span style="color:#666">=</span> <span style="color:#a2f;font-weight:bold">new</span> Map<span style="color:#666">&lt;</span>Key, Value<span style="color:#666">&gt;</span>(<span style="color:#666">*</span>old.first);
        fresh.first<span style="color:#666">-&gt;</span>insert(key, value);
        last <span style="color:#666">=</span> old.first;
      }
    } <span style="color:#a2f;font-weight:bold">while</span>(<span style="color:#666">!</span>CAS(<span style="color:#666">&amp;</span>data_, old, fresh));

    <span style="color:#080;font-style:italic">// delete it confidently
</span><span style="color:#080;font-style:italic"></span>    <span style="color:#a2f;font-weight:bold">delete</span> old.first;
  }
}
</code></pre></div><p>For <code>Lookup</code> method, if there is no <code>Update</code>s, 2 CAS usage can implement the atomic increment and decrement of the reference count. If there is an <code>Update</code> running, the <code>data.first</code> will not be modified until all other <code>Lookup</code>s related to it has returned (thanks to the <code>old.second = 1</code> in <code>Update</code>). <code>last</code> is used to avoid rebuilding the map if there is only rc modified. So it is a solution which lets <code>Update</code> waits for all <code>Lookup</code>s finishing before it is going to replace the map.</p>
<p>However, if the <code>Lookup</code>&rsquo;s rate is very high, the <code>Update</code> will be possibly starved because the rc will never decrement to one. So it is actually a WRRMBNTM (Write-Rarely-Read-Many-ButNot-Too-Many) map.</p>
    </div>

    
        <div class="tags">
            
                <a href="https://jhzhu.xyz/tags/c&#43;&#43;">C&#43;&#43;</a>
            
                <a href="https://jhzhu.xyz/tags/rust">Rust</a>
            
        </div>
    
    
    

</section>


    </main>
    
    <footer id="footer">
    
        <div id="social">


    <a class="symbol" href="https://github.com/n1ujunhui" rel="me" target="_blank">
        
        <svg fill="#bbbbbb" width="28" height="28"  viewBox="0 0 72 72" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    
    <title>Github</title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Social-Icons---Rounded-Black" transform="translate(-264.000000, -939.000000)">
            <g id="Github" transform="translate(264.000000, 939.000000)">
                <path d="M8,72 L64,72 C68.418278,72 72,68.418278 72,64 L72,8 C72,3.581722 68.418278,-8.11624501e-16 64,0 L8,0 C3.581722,8.11624501e-16 -5.41083001e-16,3.581722 0,8 L0,64 C5.41083001e-16,68.418278 3.581722,72 8,72 Z" id="Rounded" fill="#bbbbbb"></path>
                <path d="M35.9985,13 C22.746,13 12,23.7870921 12,37.096644 C12,47.7406712 18.876,56.7718301 28.4145,59.9584121 C29.6145,60.1797862 30.0525,59.4358488 30.0525,58.7973276 C30.0525,58.2250681 30.0315,56.7100863 30.0195,54.6996482 C23.343,56.1558981 21.9345,51.4693938 21.9345,51.4693938 C20.844,48.6864054 19.2705,47.9454799 19.2705,47.9454799 C17.091,46.4500754 19.4355,46.4801943 19.4355,46.4801943 C21.843,46.6503662 23.1105,48.9634994 23.1105,48.9634994 C25.2525,52.6455377 28.728,51.5823398 30.096,50.9649018 C30.3135,49.4077535 30.9345,48.3460615 31.62,47.7436831 C26.2905,47.1352808 20.688,45.0691228 20.688,35.8361671 C20.688,33.2052792 21.6225,31.0547881 23.1585,29.3696344 C22.911,28.7597262 22.0875,26.3110578 23.3925,22.9934585 C23.3925,22.9934585 25.4085,22.3459017 29.9925,25.4632101 C31.908,24.9285993 33.96,24.6620468 36.0015,24.6515052 C38.04,24.6620468 40.0935,24.9285993 42.0105,25.4632101 C46.5915,22.3459017 48.603,22.9934585 48.603,22.9934585 C49.9125,26.3110578 49.089,28.7597262 48.8415,29.3696344 C50.3805,31.0547881 51.309,33.2052792 51.309,35.8361671 C51.309,45.0917119 45.6975,47.1292571 40.3515,47.7256117 C41.2125,48.4695491 41.9805,49.9393525 41.9805,52.1877301 C41.9805,55.4089489 41.9505,58.0067059 41.9505,58.7973276 C41.9505,59.4418726 42.3825,60.1918338 43.6005,59.9554002 C53.13,56.7627944 60,47.7376593 60,37.096644 C60,23.7870921 49.254,13 35.9985,13" fill="#FFFFFF"></path>
            </g>
        </g>
    </g>
</svg>
    </a>

    <a class="symbol" href="https://twitter.com/niujunhui" rel="me" target="_blank">
        
        <svg fill="#bbbbbb" width="28" height="28" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 width="438.536px" height="438.536px" viewBox="0 0 438.536 438.536" style="enable-background:new 0 0 438.536 438.536;"
	 xml:space="preserve">
<g>
	<path d="M414.41,24.123C398.333,8.042,378.963,0,356.315,0H82.228C59.58,0,40.21,8.042,24.126,24.123
		C8.045,40.207,0.003,59.576,0.003,82.225v274.084c0,22.647,8.042,42.018,24.123,58.102c16.084,16.084,35.454,24.126,58.102,24.126
		h274.084c22.648,0,42.018-8.042,58.095-24.126c16.084-16.084,24.126-35.454,24.126-58.102V82.225
		C438.532,59.576,430.49,40.204,414.41,24.123z M335.471,168.735c0.191,1.713,0.288,4.278,0.288,7.71
		c0,15.989-2.334,32.025-6.995,48.104c-4.661,16.087-11.8,31.504-21.416,46.254c-9.606,14.749-21.074,27.791-34.396,39.115
		c-13.325,11.32-29.311,20.365-47.968,27.117c-18.648,6.762-38.637,10.143-59.953,10.143c-33.116,0-63.76-8.952-91.931-26.836
		c4.568,0.568,9.329,0.855,14.275,0.855c27.6,0,52.439-8.565,74.519-25.7c-12.941-0.185-24.506-4.179-34.688-11.991
		c-10.185-7.803-17.273-17.699-21.271-29.691c4.947,0.76,8.658,1.137,11.132,1.137c4.187,0,9.042-0.76,14.56-2.279
		c-13.894-2.669-25.598-9.562-35.115-20.697c-9.519-11.136-14.277-23.84-14.277-38.114v-0.571
		c10.085,4.755,19.602,7.229,28.549,7.422c-17.321-11.613-25.981-28.265-25.981-49.963c0-10.66,2.758-20.747,8.278-30.264
		c15.035,18.464,33.311,33.213,54.816,44.252c21.507,11.038,44.54,17.227,69.092,18.558c-0.95-3.616-1.427-8.186-1.427-13.704
		c0-16.562,5.853-30.692,17.56-42.399c11.703-11.706,25.837-17.561,42.394-17.561c17.515,0,32.079,6.283,43.688,18.846
		c13.134-2.474,25.892-7.33,38.26-14.56c-4.757,14.652-13.613,25.788-26.55,33.402c12.368-1.716,23.88-4.95,34.537-9.708
		C357.458,149.793,347.462,160.166,335.471,168.735z"/>
</g>
</svg>

    </a>


</div>

    

    <div class="copyright">
    
       © Copyright 
       2023 
       <span class="split">
        <svg fill="#bbbbbb" width="15" height="15" version="1.1" id="heart-15" xmlns="http://www.w3.org/2000/svg" width="15px" height="15px" viewBox="0 0 15 15">
  <path d="M13.91,6.75c-1.17,2.25-4.3,5.31-6.07,6.94c-0.1903,0.1718-0.4797,0.1718-0.67,0C5.39,12.06,2.26,9,1.09,6.75&#xA;&#x9;C-1.48,1.8,5-1.5,7.5,3.45C10-1.5,16.48,1.8,13.91,6.75z"/>
</svg>
       </span>
       Junhui Zhu
    
    </div>

    
      <div class="powerby">
        Powered by <a href='http://www.gohugo.io/'>Hugo</a> Theme By <a href='https://github.com/nodejh/hugo-theme-mini'>nodejh</a>
      </div>
    
</footer>



  </body>
</html>
