<!DOCTYPE html>
<html lang="en-us">
  <head>
    <title>CSAPP Chapter 10 | Jim Zhu</title>

    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">    
<meta name="viewport" content="width=device-width,minimum-scale=1">
<meta name="description" content="RIO without buffer 🔗ssize_t rio_readn(int fd, void *usrbuf, size_t n); 和 Unix IO 的 read 函数的区别： 被中断打断可以重新读 成功时返回 0， 遇到 EOF 时同样返回差值。 ssize_t rio_writen(int fd, void *usrbuf, size_t n); 被中断打断可以">
<meta name="generator" content="Hugo 0.82.1" />


  <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">


<link rel="stylesheet" href="/css/style.css">



<link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon" />







  </head>

  <body>
    <nav class="navigation">
	
		<a href="/"> <span class="arrow">←</span>Home</a>
	
	<a href="/posts">Archive</a>
	<a href="/tags">Tags</a>
	<a href="/about">About</a>

	

	
	  <a class="button" href="https://zhujunhui.com/index.xml">Subscribe</a>
	
</nav>


    <main class="main">
      

<section id="single">
    <h1 class="title">CSAPP Chapter 10</h1>

    <div class="tip">
        <time datetime="2021-05-12 16:45:57 &#43;0800 &#43;0800">May 12, 2021</time>
        <span class="split">
          ·
        </span>
        <span>
          937 words
        </span>
        <span class="split">
          ·
        </span>
        <span>
          2 minute read
        </span>
    </div>

    
    
        
  
    <aside class="toc">
      <details>
          <summary>Table of Contents
          </summary>
          <div>
              <nav id="TableOfContents">
  <ul>
    <li><a href="#rio-without-buffer">RIO without buffer</a></li>
    <li><a href="#rio-input-with-buffer">RIO Input with buffer</a></li>
    <li><a href="#为什么网络编程不要用标准-io">为什么网络编程不要用标准 I/O？</a></li>
    <li><a href="#proxy-lab">Proxy lab</a>
      <ul>
        <li><a href="#一些辅助函数">一些辅助函数</a></li>
      </ul>
    </li>
  </ul>
</nav>
          </div>
      </details>
    </aside>
  


    


    <div class="content">
      <h2 id="rio-without-buffer">RIO without buffer <a href="#rio-without-buffer" class="anchor">🔗</a></h2><div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C">ssize_t <span style="color:#00a000">rio_readn</span>(<span style="color:#0b0;font-weight:bold">int</span> fd, <span style="color:#0b0;font-weight:bold">void</span> <span style="color:#666">*</span>usrbuf, size_t n);
</code></pre></div><p>和 Unix IO 的 <code>read</code> 函数的区别：</p>
<ul>
<li>被中断打断可以重新读</li>
</ul>
<p>成功时返回 0， 遇到 EOF 时同样返回差值。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C">ssize_t <span style="color:#00a000">rio_writen</span>(<span style="color:#0b0;font-weight:bold">int</span> fd, <span style="color:#0b0;font-weight:bold">void</span> <span style="color:#666">*</span>usrbuf, size_t n);
</code></pre></div><ul>
<li>被中断打断可以重新写</li>
<li>失败时返回 -1</li>
</ul>
<h2 id="rio-input-with-buffer">RIO Input with buffer <a href="#rio-input-with-buffer" class="anchor">🔗</a></h2><ul>
<li><code>void rio_readinitb(rio_t *rp, int fd);</code></li>
</ul>
<p>将文件描述符 <code>fd</code> 与 读缓冲区 <code>rp</code> 绑定</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#080">#define RIO_BUFSIZE 8192
</span><span style="color:#080"></span><span style="color:#a2f;font-weight:bold">typedef</span> <span style="color:#a2f;font-weight:bold">struct</span> {
    <span style="color:#0b0;font-weight:bold">int</span> rio_fd;
    <span style="color:#0b0;font-weight:bold">int</span> rio_cnt;				<span style="color:#080;font-style:italic">/* 应用级缓冲中未被使用的字节数 */</span>
    <span style="color:#0b0;font-weight:bold">char</span> <span style="color:#666">*</span>rio_bufptr;			<span style="color:#080;font-style:italic">/* 下一个未被读取的字节地址 */</span>
    <span style="color:#0b0;font-weight:bold">char</span> rio_buf[RIO_BUFSIZE];	<span style="color:#080;font-style:italic">/* buffer */</span>
} rio_t;

<span style="color:#0b0;font-weight:bold">void</span> <span style="color:#00a000">rio_readinitb</span>(rio_t <span style="color:#666">*</span>rp, <span style="color:#0b0;font-weight:bold">int</span> fd) {
    rp<span style="color:#666">-&gt;</span>rio_fd <span style="color:#666">=</span> fd;
    rp<span style="color:#666">-&gt;</span>rio_cnt <span style="color:#666">=</span> <span style="color:#666">0</span>;
    rp<span style="color:#666">-&gt;</span>rio_bufptr <span style="color:#666">=</span> rp<span style="color:#666">-&gt;</span>rio_buf;
}
</code></pre></div><ul>
<li>辅助函数：<code>static ssize_t rio_read(rio_t *rp, char *usrbuf, size_t n);</code></li>
</ul>
<p>对于应用程序来说，<code>rio_read</code> 和 Unix IO 提供的 <code>read</code> 的语义是一样的。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#a2f;font-weight:bold">static</span> ssize_t <span style="color:#00a000">rio_read</span>(rio_t <span style="color:#666">*</span>rp, <span style="color:#0b0;font-weight:bold">char</span> <span style="color:#666">*</span>usrbuf, size_t n) {
    
    <span style="color:#0b0;font-weight:bold">int</span> cnt;
    <span style="color:#a2f;font-weight:bold">while</span> (rp<span style="color:#666">-&gt;</span>rio_cnt <span style="color:#666">&lt;=</span> <span style="color:#666">0</span>) {
        rp<span style="color:#666">-&gt;</span>rio_cnt <span style="color:#666">=</span> read(rp<span style="color:#666">-&gt;</span>rio_fd, rp<span style="color:#666">-&gt;</span>rio_buf, <span style="color:#a2f;font-weight:bold">sizeof</span>(rp<span style="color:#666">-&gt;</span>rio_buf));
        
        <span style="color:#a2f;font-weight:bold">if</span>(rp<span style="color:#666">-&gt;</span>rio_cnt <span style="color:#666">&lt;</span> <span style="color:#666">0</span>) {
            <span style="color:#a2f;font-weight:bold">if</span> (errno <span style="color:#666">!=</span> EINTR)
                <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#666">-</span><span style="color:#666">1</span>; <span style="color:#080;font-style:italic">/* 被除了 sig handler 以外的中断打断，说明出错了 */</span>
        }
        <span style="color:#a2f;font-weight:bold">else</span> <span style="color:#a2f;font-weight:bold">if</span> (rp<span style="color:#666">-&gt;</span>rio_cnt <span style="color:#666">==</span> <span style="color:#666">0</span>)
            <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#666">0</span>; <span style="color:#080;font-style:italic">/* 读到 EOF 了，结束 */</span>
        <span style="color:#a2f;font-weight:bold">else</span>
            rp<span style="color:#666">-&gt;</span>rio_bufptr <span style="color:#666">=</span> rp<span style="color:#666">-&gt;</span>rio_buf;
        <span style="color:#080;font-style:italic">/* 这里隐含了一件事情，当 rp-&gt;rio_cnt&lt;0 且 errno = EINTR 时，会重新读 */</span>
    }
    
    <span style="color:#080;font-style:italic">/* 将 min(n, rp-&gt;rio_cnt) 数量的字节拷贝到 usrbuf */</span>
    <span style="color:#080;font-style:italic">/* 返回 min(n, rp-&gt;rio_cnt) */</span>
    <span style="color:#080;font-style:italic">/* 当所需要读取的字节数超过了缓冲区内空闲的字节数量，返回剩下的数量 */</span>
    
    cnt <span style="color:#666">=</span> n;
    <span style="color:#a2f;font-weight:bold">if</span> (rp<span style="color:#666">-&gt;</span>rio_cnt <span style="color:#666">&lt;</span> n)
        cnt <span style="color:#666">=</span> rp<span style="color:#666">-&gt;</span>rio_cnt;
    memcpy(usrbuf, rp<span style="color:#666">-&gt;</span>rio_bufptr, cnt);
    rp<span style="color:#666">-&gt;</span>rio_bufptr <span style="color:#666">+=</span> cnt;
    rp<span style="color:#666">-&gt;</span>rio_cnt <span style="color:#666">-=</span>cnt;
    <span style="color:#a2f;font-weight:bold">return</span> cnt;
}
</code></pre></div><ul>
<li>读取一行：<code>ssize_t rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen);</code></li>
</ul>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C">ssize_t <span style="color:#00a000">rio_readlineb</span>(rio_t <span style="color:#666">*</span>rp, <span style="color:#0b0;font-weight:bold">void</span> <span style="color:#666">*</span>usrbuf, size_t maxlen) {
    
    <span style="color:#080;font-style:italic">/* 至多读取 maxlen-1 个字符，因为有字符串结束符 */</span>
    <span style="color:#0b0;font-weight:bold">int</span> n, rc;
    <span style="color:#0b0;font-weight:bold">char</span> c, <span style="color:#666">*</span>bufp <span style="color:#666">=</span> usrbuf;
    
    <span style="color:#a2f;font-weight:bold">for</span> (n <span style="color:#666">=</span> <span style="color:#666">1</span>; n <span style="color:#666">&lt;</span> maxlen; n<span style="color:#666">++</span>) {
        <span style="color:#a2f;font-weight:bold">if</span> ((rc <span style="color:#666">=</span> rio_read(rp, <span style="color:#666">&amp;</span>c, <span style="color:#666">1</span>)) <span style="color:#666">==</span> <span style="color:#666">1</span>) {
            <span style="color:#666">*</span>bufp<span style="color:#666">++</span> <span style="color:#666">=</span> c;
            <span style="color:#a2f;font-weight:bold">if</span> (c <span style="color:#666">==</span> <span style="color:#b44">&#39;\n&#39;</span>) {
                n<span style="color:#666">++</span>;
                <span style="color:#a2f;font-weight:bold">break</span>;
            }
        } <span style="color:#a2f;font-weight:bold">else</span> <span style="color:#a2f;font-weight:bold">if</span> (rc <span style="color:#666">==</span> <span style="color:#666">0</span>) {
            <span style="color:#a2f;font-weight:bold">if</span> (n <span style="color:#666">==</span> <span style="color:#666">1</span>)
                <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#666">0</span>;
            <span style="color:#a2f;font-weight:bold">else</span>
                <span style="color:#a2f;font-weight:bold">break</span>;
        } <span style="color:#a2f;font-weight:bold">else</span>
            <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#666">-</span><span style="color:#666">1</span>;
    }
    <span style="color:#666">*</span>bufp <span style="color:#666">=</span> <span style="color:#666">0</span>;
    <span style="color:#a2f;font-weight:bold">return</span> n<span style="color:#666">-</span><span style="color:#666">1</span>;
}
</code></pre></div><ul>
<li>读取 <code>n</code> 个字符：<code>ssize_t rio_readnb(rio_t *rp, void *usrbuf, size_t n);</code></li>
</ul>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C">ssize_t <span style="color:#00a000">rio_readnb</span>(rio_t <span style="color:#666">*</span>rp, <span style="color:#0b0;font-weight:bold">void</span> <span style="color:#666">*</span>usrbuf, size_t n) {
    size_t nleft <span style="color:#666">=</span> n;
    ssize_t nread;
    <span style="color:#0b0;font-weight:bold">char</span> <span style="color:#666">*</span>bufp <span style="color:#666">=</span> usrbuf;
    <span style="color:#a2f;font-weight:bold">while</span>(nleft <span style="color:#666">&gt;</span> <span style="color:#666">0</span>) {
        <span style="color:#a2f;font-weight:bold">if</span>(nread <span style="color:#666">=</span> rio_read(rp, usrbuf, nleft) <span style="color:#666">&lt;</span> <span style="color:#666">0</span>)
            <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#666">-</span><span style="color:#666">1</span>; <span style="color:#080;font-style:italic">/* 出错 */</span>
        <span style="color:#a2f;font-weight:bold">else</span> <span style="color:#a2f;font-weight:bold">if</span> (nread <span style="color:#666">==</span> <span style="color:#666">0</span>)
            <span style="color:#a2f;font-weight:bold">break</span>;
        nleft <span style="color:#666">-=</span> nread;
        bufp <span style="color:#666">+=</span> nread;
    }
    <span style="color:#a2f;font-weight:bold">return</span> n<span style="color:#666">-</span>nleft;
}
</code></pre></div><p><strong>带缓冲的函数可以任意交叉运行，线程安全，但不可以和无缓冲的 <code>rio_readn</code> 交叉使用</strong>。因为部分数据还存留在应用层的缓冲区内。</p>
<h2 id="为什么网络编程不要用标准-io">为什么网络编程不要用标准 I/O？ <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e7%bd%91%e7%bb%9c%e7%bc%96%e7%a8%8b%e4%b8%8d%e8%a6%81%e7%94%a8%e6%a0%87%e5%87%86-io" class="anchor">🔗</a></h2><div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#080">#include</span> <span style="color:#080">&#34;unp.h&#34;</span><span style="color:#080">
</span><span style="color:#080"></span>
<span style="color:#0b0;font-weight:bold">void</span> <span style="color:#00a000">str_echo</span>(<span style="color:#0b0;font-weight:bold">int</span> sockfd) {
    <span style="color:#0b0;font-weight:bold">char</span> line[MAXLINE];
    FILE <span style="color:#666">*</span>fpin, <span style="color:#666">*</span>fpout;
    
    fpin <span style="color:#666">=</span> Fdopen(sockfd, <span style="color:#b44">&#34;r&#34;</span>);
    fpout <span style="color:#666">=</span> Fdopen(sockfd, <span style="color:#b44">&#34;w&#34;</span>);
    
    <span style="color:#a2f;font-weight:bold">while</span> (Fgets(line, MAXLINE, fpin) <span style="color:#666">!=</span> <span style="color:#a2f">NULL</span>)
        Fputs(lines, fpout);
}
</code></pre></div><ol>
<li>先调用 <code>fdopen</code> 创建两个标准 I/O Stream，一个用于输入一个用于输出。</li>
</ol>
<h2 id="proxy-lab">Proxy lab <a href="#proxy-lab" class="anchor">🔗</a></h2><p>proxy 需要往屏幕上打印日志，格式：</p>
<p><code>Date: browserIP URL size</code></p>
<p><code>size</code> 是代理程序从连接建立到连接关闭中从服务器收到的字节数，只有被服务器响应的请求才会被记录。</p>
<h3 id="一些辅助函数">一些辅助函数 <a href="#%e4%b8%80%e4%ba%9b%e8%be%85%e5%8a%a9%e5%87%bd%e6%95%b0" class="anchor">🔗</a></h3><ol>
<li>
<p><code>int getaddrinfo(const char *host, const char *service, const struct addrinfo *hints, struct addrinfo **result);</code></p>
<p>处理<strong>名字到地址</strong>以及<strong>服务到端口</strong>这两种转换</p>
<p>参数：</p>
<ul>
<li><code>hostname</code>：一个主机名或者一个地址串</li>
<li><code>service</code>：十进制端口号或者是预先定义好的服务名</li>
<li><code>hints</code>：一个指向 <code>addrinfo</code> 结构体的指针，包含期望返回的格式信息</li>
<li><code>result</code>：函数通过该指针返回一个<strong>指向 <code>addrinfo</code> 链表的指针</strong></li>
</ul>
<p>返回值：</p>
<ul>
<li>成功：0</li>
<li>出错：非 0</li>
</ul>
</li>
</ol>

    </div>

    
    
    

</section>


    </main>
    
    <footer id="footer">
    
        <div id="social">


    <a class="symbol" href="https://github.com/n1ujunhui" rel="me" target="_blank">
        
        <svg fill="#bbbbbb" width="28" height="28"  viewBox="0 0 72 72" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    
    <title>Github</title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Social-Icons---Rounded-Black" transform="translate(-264.000000, -939.000000)">
            <g id="Github" transform="translate(264.000000, 939.000000)">
                <path d="M8,72 L64,72 C68.418278,72 72,68.418278 72,64 L72,8 C72,3.581722 68.418278,-8.11624501e-16 64,0 L8,0 C3.581722,8.11624501e-16 -5.41083001e-16,3.581722 0,8 L0,64 C5.41083001e-16,68.418278 3.581722,72 8,72 Z" id="Rounded" fill="#bbbbbb"></path>
                <path d="M35.9985,13 C22.746,13 12,23.7870921 12,37.096644 C12,47.7406712 18.876,56.7718301 28.4145,59.9584121 C29.6145,60.1797862 30.0525,59.4358488 30.0525,58.7973276 C30.0525,58.2250681 30.0315,56.7100863 30.0195,54.6996482 C23.343,56.1558981 21.9345,51.4693938 21.9345,51.4693938 C20.844,48.6864054 19.2705,47.9454799 19.2705,47.9454799 C17.091,46.4500754 19.4355,46.4801943 19.4355,46.4801943 C21.843,46.6503662 23.1105,48.9634994 23.1105,48.9634994 C25.2525,52.6455377 28.728,51.5823398 30.096,50.9649018 C30.3135,49.4077535 30.9345,48.3460615 31.62,47.7436831 C26.2905,47.1352808 20.688,45.0691228 20.688,35.8361671 C20.688,33.2052792 21.6225,31.0547881 23.1585,29.3696344 C22.911,28.7597262 22.0875,26.3110578 23.3925,22.9934585 C23.3925,22.9934585 25.4085,22.3459017 29.9925,25.4632101 C31.908,24.9285993 33.96,24.6620468 36.0015,24.6515052 C38.04,24.6620468 40.0935,24.9285993 42.0105,25.4632101 C46.5915,22.3459017 48.603,22.9934585 48.603,22.9934585 C49.9125,26.3110578 49.089,28.7597262 48.8415,29.3696344 C50.3805,31.0547881 51.309,33.2052792 51.309,35.8361671 C51.309,45.0917119 45.6975,47.1292571 40.3515,47.7256117 C41.2125,48.4695491 41.9805,49.9393525 41.9805,52.1877301 C41.9805,55.4089489 41.9505,58.0067059 41.9505,58.7973276 C41.9505,59.4418726 42.3825,60.1918338 43.6005,59.9554002 C53.13,56.7627944 60,47.7376593 60,37.096644 C60,23.7870921 49.254,13 35.9985,13" fill="#FFFFFF"></path>
            </g>
        </g>
    </g>
</svg>
    </a>

    <a class="symbol" href="https://twitter.com/niujunhui" rel="me" target="_blank">
        
        <svg fill="#bbbbbb" width="28" height="28" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 width="438.536px" height="438.536px" viewBox="0 0 438.536 438.536" style="enable-background:new 0 0 438.536 438.536;"
	 xml:space="preserve">
<g>
	<path d="M414.41,24.123C398.333,8.042,378.963,0,356.315,0H82.228C59.58,0,40.21,8.042,24.126,24.123
		C8.045,40.207,0.003,59.576,0.003,82.225v274.084c0,22.647,8.042,42.018,24.123,58.102c16.084,16.084,35.454,24.126,58.102,24.126
		h274.084c22.648,0,42.018-8.042,58.095-24.126c16.084-16.084,24.126-35.454,24.126-58.102V82.225
		C438.532,59.576,430.49,40.204,414.41,24.123z M335.471,168.735c0.191,1.713,0.288,4.278,0.288,7.71
		c0,15.989-2.334,32.025-6.995,48.104c-4.661,16.087-11.8,31.504-21.416,46.254c-9.606,14.749-21.074,27.791-34.396,39.115
		c-13.325,11.32-29.311,20.365-47.968,27.117c-18.648,6.762-38.637,10.143-59.953,10.143c-33.116,0-63.76-8.952-91.931-26.836
		c4.568,0.568,9.329,0.855,14.275,0.855c27.6,0,52.439-8.565,74.519-25.7c-12.941-0.185-24.506-4.179-34.688-11.991
		c-10.185-7.803-17.273-17.699-21.271-29.691c4.947,0.76,8.658,1.137,11.132,1.137c4.187,0,9.042-0.76,14.56-2.279
		c-13.894-2.669-25.598-9.562-35.115-20.697c-9.519-11.136-14.277-23.84-14.277-38.114v-0.571
		c10.085,4.755,19.602,7.229,28.549,7.422c-17.321-11.613-25.981-28.265-25.981-49.963c0-10.66,2.758-20.747,8.278-30.264
		c15.035,18.464,33.311,33.213,54.816,44.252c21.507,11.038,44.54,17.227,69.092,18.558c-0.95-3.616-1.427-8.186-1.427-13.704
		c0-16.562,5.853-30.692,17.56-42.399c11.703-11.706,25.837-17.561,42.394-17.561c17.515,0,32.079,6.283,43.688,18.846
		c13.134-2.474,25.892-7.33,38.26-14.56c-4.757,14.652-13.613,25.788-26.55,33.402c12.368-1.716,23.88-4.95,34.537-9.708
		C357.458,149.793,347.462,160.166,335.471,168.735z"/>
</g>
</svg>

    </a>


</div>

    

    <div class="copyright">
    
       © Copyright 
       2022 
       <span class="split">
        <svg fill="#bbbbbb" width="15" height="15" version="1.1" id="heart-15" xmlns="http://www.w3.org/2000/svg" width="15px" height="15px" viewBox="0 0 15 15">
  <path d="M13.91,6.75c-1.17,2.25-4.3,5.31-6.07,6.94c-0.1903,0.1718-0.4797,0.1718-0.67,0C5.39,12.06,2.26,9,1.09,6.75&#xA;&#x9;C-1.48,1.8,5-1.5,7.5,3.45C10-1.5,16.48,1.8,13.91,6.75z"/>
</svg>
       </span>
       Junhui Zhu
    
    </div>

    
      <div class="powerby">
        Powered by <a href='http://www.gohugo.io/'>Hugo</a> Theme By <a href='https://github.com/nodejh/hugo-theme-mini'>nodejh</a>
      </div>
    
</footer>



  </body>
</html>
