<!DOCTYPE html>
<html lang="en-us">
  <head>
    <title>重新学习 Modern Cpp | Jim Zhu</title>

    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">    
<meta name="viewport" content="width=device-width,minimum-scale=1">
<meta name="description" content="记录一些 Modern Cpp 的学习。">
<meta name="generator" content="Hugo 0.82.1" />


  <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">


<link rel="stylesheet" href="/css/style.css">



<link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon" />







  </head>

  <body>
    <nav class="navigation">
	
		<a href="/"> <span class="arrow">←</span>Home</a>
	
	<a href="/posts">Archive</a>
	<a href="/tags">Tags</a>
	<a href="/about">About</a>

	
		<a href="https://www.zhihu.com/people/zhu-jun-hui-40-47">Zhihu</a>
	

	
	  <a class="button" href="https://zhujunhui.com/index.xml">Subscribe</a>
	
</nav>


    <main class="main">
      

<section id="single">
    <h1 class="title">重新学习 Modern Cpp</h1>

    <div class="tip">
        <time datetime="2022-05-14 00:00:00 &#43;0000 UTC">May 14, 2022</time>
        <span class="split">
          ·
        </span>
        <span>
          1485 words
        </span>
        <span class="split">
          ·
        </span>
        <span>
          3 minute read
        </span>
    </div>

    
    
        
  
    <aside class="toc">
      <details>
          <summary>Table of Contents
          </summary>
          <div>
              <nav id="TableOfContents">
  <ul>
    <li><a href="#type-deduction">Type Deduction</a>
      <ul>
        <li><a href="#template-type-deduction">Template Type Deduction</a></li>
        <li><a href="#understand-auto">Understand <code>auto</code></a></li>
      </ul>
    </li>
  </ul>
</nav>
          </div>
      </details>
    </aside>
  


    


    <div class="content">
      <p>记录一些 Modern Cpp 的学习。</p>
<h2 id="type-deduction">Type Deduction <a href="#type-deduction" class="anchor">🔗</a></h2><h3 id="template-type-deduction">Template Type Deduction <a href="#template-type-deduction" class="anchor">🔗</a></h3><p>将 Template Type Deduction 看做一个这样的函数模板：</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#a2f;font-weight:bold">template</span><span style="color:#666">&lt;</span><span style="color:#a2f;font-weight:bold">typename</span> T<span style="color:#666">&gt;</span>
<span style="color:#0b0;font-weight:bold">void</span> f(ParamType param);
</code></pre></div><p>编译器就像一个黑箱，接受一个表达式 <code>expr</code> 并根据 <code>ParamType</code> 的形式，推导出 <code>T</code> 和 <code>param</code> 的实际类型。</p>
<h4 id="paramtype-是一个引用或者指针时">ParamType 是一个引用或者指针时， <a href="#paramtype-%e6%98%af%e4%b8%80%e4%b8%aa%e5%bc%95%e7%94%a8%e6%88%96%e8%80%85%e6%8c%87%e9%92%88%e6%97%b6" class="anchor">🔗</a></h4><ol>
<li>忽略 <code>expr</code> 的引用；</li>
<li>根据忽略引用后的类型和 <code>ParamType</code> 进行模式匹配。</li>
</ol>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#a2f;font-weight:bold">template</span><span style="color:#666">&lt;</span><span style="color:#a2f;font-weight:bold">typename</span> T<span style="color:#666">&gt;</span>
<span style="color:#0b0;font-weight:bold">void</span> f(T<span style="color:#666">&amp;</span> param);

<span style="color:#0b0;font-weight:bold">int</span> x <span style="color:#666">=</span> <span style="color:#666">1</span>;
f(x); <span style="color:#080;font-style:italic">// T 被推导为 int，param 被推导为 int &amp;
</span><span style="color:#080;font-style:italic"></span>
<span style="color:#a2f;font-weight:bold">const</span> <span style="color:#0b0;font-weight:bold">int</span> cx <span style="color:#666">=</span> x;
f(cx); <span style="color:#080;font-style:italic">// T 被推导为 const int，param 被推导为 const int &amp;
</span><span style="color:#080;font-style:italic"></span>
<span style="color:#a2f;font-weight:bold">const</span> <span style="color:#0b0;font-weight:bold">int</span> <span style="color:#666">&amp;</span> rx <span style="color:#666">=</span> x;
f(rx) <span style="color:#080;font-style:italic">// T 被推导为 const int，param 被推导为 const int &amp;
</span></code></pre></div><p>我自己的理解：将 <code>T&amp;</code> 用 backwards 的方法展开：reference to T，这里的 T 和 expr 的类型进行模式匹配。
因此，当传递一个 const 对象给 <code>T&amp;</code> 时，该对象在函数中也保持了 constness。</p>
<p>当 <code>ParamType</code> 是 <code>const T &amp;</code> aka reference to const T 时，<code>x</code> 作为 <code>expr</code> 会让 <code>T</code> 被规约为 int，但是 <code>cx</code> 和 <code>rx</code> 也会让 <code>T</code> 被规约为 int，因为 const 特性已经在 <code>ParamType</code> 里了。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#a2f;font-weight:bold">template</span><span style="color:#666">&lt;</span><span style="color:#a2f;font-weight:bold">typename</span> T<span style="color:#666">&gt;</span>
<span style="color:#0b0;font-weight:bold">void</span> f(<span style="color:#a2f;font-weight:bold">const</span> T<span style="color:#666">&amp;</span> param);

<span style="color:#0b0;font-weight:bold">int</span> x <span style="color:#666">=</span> <span style="color:#666">1</span>;
f(x); <span style="color:#080;font-style:italic">// T 被推导为 int，param 被推导为 const int &amp;
</span><span style="color:#080;font-style:italic"></span>
<span style="color:#a2f;font-weight:bold">const</span> <span style="color:#0b0;font-weight:bold">int</span> cx <span style="color:#666">=</span> x;
f(cx); <span style="color:#080;font-style:italic">// T 被推导为 int，param 被推导为 const int &amp;
</span><span style="color:#080;font-style:italic"></span>
<span style="color:#a2f;font-weight:bold">const</span> <span style="color:#0b0;font-weight:bold">int</span> <span style="color:#666">&amp;</span> rx <span style="color:#666">=</span> x;
f(rx) <span style="color:#080;font-style:italic">// T 被推导为 int，param 被推导为 const int &amp;
</span></code></pre></div><p>这也是很自然的结果，因为在函数中制定 parameter 是 const 的目的便是避免对其修改。</p>
<p>同样，当 <code>ParamType</code> 是指针时，</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#a2f;font-weight:bold">template</span><span style="color:#666">&lt;</span><span style="color:#a2f;font-weight:bold">typename</span> T<span style="color:#666">&gt;</span>
<span style="color:#0b0;font-weight:bold">void</span> f(T<span style="color:#666">*</span> param);

<span style="color:#0b0;font-weight:bold">int</span> x <span style="color:#666">=</span> <span style="color:#666">1</span>;
<span style="color:#a2f;font-weight:bold">const</span> <span style="color:#0b0;font-weight:bold">int</span> <span style="color:#666">*</span>px <span style="color:#666">=</span> <span style="color:#666">&amp;</span>x;

f(<span style="color:#666">&amp;</span>x); <span style="color:#080;font-style:italic">// T 被推导为 int，param 被被推导为 int*
</span><span style="color:#080;font-style:italic"></span>f(px); <span style="color:#080;font-style:italic">// T 被推导为 const int，param 被被推导为 const int*
</span></code></pre></div><p>加了 const 后：</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#a2f;font-weight:bold">template</span><span style="color:#666">&lt;</span><span style="color:#a2f;font-weight:bold">typename</span> T<span style="color:#666">&gt;</span>
<span style="color:#0b0;font-weight:bold">void</span> f(<span style="color:#a2f;font-weight:bold">const</span> T<span style="color:#666">*</span> param);

<span style="color:#0b0;font-weight:bold">int</span> x <span style="color:#666">=</span> <span style="color:#666">1</span>;
<span style="color:#a2f;font-weight:bold">const</span> <span style="color:#0b0;font-weight:bold">int</span> <span style="color:#666">*</span>px <span style="color:#666">=</span> <span style="color:#666">&amp;</span>x;

f(<span style="color:#666">&amp;</span>x); <span style="color:#080;font-style:italic">// T 被推导为 int，param 被被推导为 const int*
</span><span style="color:#080;font-style:italic"></span>f(px); <span style="color:#080;font-style:italic">// T 被推导为 int，param 被被推导为 const int*
</span></code></pre></div><p>下面的代码是不能通过编译的：</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#a2f;font-weight:bold">template</span><span style="color:#666">&lt;</span><span style="color:#a2f;font-weight:bold">typename</span> T<span style="color:#666">&gt;</span>
<span style="color:#0b0;font-weight:bold">void</span> f(T<span style="color:#666">*</span> <span style="color:#a2f;font-weight:bold">const</span> param);

<span style="color:#a2f;font-weight:bold">const</span> <span style="color:#0b0;font-weight:bold">int</span> x <span style="color:#666">=</span> <span style="color:#666">1</span>;

f(<span style="color:#666">&amp;</span>x); <span style="color:#080;font-style:italic">// 破坏了 x 的 constness
</span></code></pre></div><h4 id="paramtype-是一个通用引用时">ParamType 是一个通用引用时， <a href="#paramtype-%e6%98%af%e4%b8%80%e4%b8%aa%e9%80%9a%e7%94%a8%e5%bc%95%e7%94%a8%e6%97%b6" class="anchor">🔗</a></h4><div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#a2f;font-weight:bold">template</span><span style="color:#666">&lt;</span><span style="color:#a2f;font-weight:bold">typename</span> T<span style="color:#666">&gt;</span>
<span style="color:#0b0;font-weight:bold">void</span> f(T<span style="color:#666">&amp;&amp;</span> param);
</code></pre></div><p>这样的通用引用是可以接受左值 argument 的，当 argument 是右值时和上面是一样的。</p>
<p>当 argument 是左值时，<code>T</code> 和 <code>ParamType</code> 都会被推导为左值引用。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#a2f;font-weight:bold">template</span><span style="color:#666">&lt;</span><span style="color:#a2f;font-weight:bold">typename</span> T<span style="color:#666">&gt;</span>
<span style="color:#0b0;font-weight:bold">void</span> f(T<span style="color:#666">&amp;&amp;</span> param);

<span style="color:#0b0;font-weight:bold">int</span> x <span style="color:#666">=</span> <span style="color:#666">1</span><span style="">；</span>
<span style="color:#a2f;font-weight:bold">const</span> <span style="color:#0b0;font-weight:bold">int</span> cx <span style="color:#666">=</span> x;
<span style="color:#a2f;font-weight:bold">const</span> <span style="color:#0b0;font-weight:bold">int</span> <span style="color:#666">&amp;</span> rx <span style="color:#666">=</span> cx;

f(x); <span style="color:#080;font-style:italic">// T 和 ParamType 都是 int &amp;
</span><span style="color:#080;font-style:italic"></span>f(cx); <span style="color:#080;font-style:italic">// T 和 ParamType 都是 const int &amp;
</span><span style="color:#080;font-style:italic"></span>f(rx); <span style="color:#080;font-style:italic">// T 和 ParamType 都是 const int &amp;
</span><span style="color:#080;font-style:italic"></span>f(<span style="color:#666">1</span>); <span style="color:#080;font-style:italic">// T 是 int，ParamType 是 int &amp;&amp;
</span></code></pre></div><h4 id="paramtype-不是引用也不是指针时">ParamType 不是引用也不是指针时 <a href="#paramtype-%e4%b8%8d%e6%98%af%e5%bc%95%e7%94%a8%e4%b9%9f%e4%b8%8d%e6%98%af%e6%8c%87%e9%92%88%e6%97%b6" class="anchor">🔗</a></h4><p>这种情况下，总是会 copy 一份 argument，因此忽略 argument 自己的引用和 constness 或者 <code>volatile</code> 特性。</p>
<h4 id="数组或者函数-argument">数组或者函数 argument <a href="#%e6%95%b0%e7%bb%84%e6%88%96%e8%80%85%e5%87%bd%e6%95%b0-argument" class="anchor">🔗</a></h4><p>对一个普通函数来说，如果 parameter 是一个数组类型，那其实就是一个指针类型。换言之，<code>f(int param[])</code> 和 <code>f(int *param)</code> 是一回事。</p>
<p>但是模板函数中的 <code>ParamType</code> 包含引用时，可以获取到数组的所有信息，也就是说 <code>T</code> 会被推导为一个数组类型而不是指针。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#a2f;font-weight:bold">template</span><span style="color:#666">&lt;</span><span style="color:#a2f;font-weight:bold">typename</span> T<span style="color:#666">&gt;</span>
<span style="color:#0b0;font-weight:bold">void</span> f(T<span style="color:#666">&amp;</span> param);

<span style="color:#0b0;font-weight:bold">int</span> arr[] <span style="color:#666">=</span> {<span style="color:#666">1</span>, <span style="color:#666">2</span>, <span style="color:#666">3</span>};
f(arr);
<span style="color:#080;font-style:italic">// T 被推导为 int [3]
</span><span style="color:#080;font-style:italic">// param 被推导为 int (&amp;)[3]
</span><span style="color:#080;font-style:italic"></span>
<span style="color:#080;font-style:italic">/**
</span><span style="color:#080;font-style:italic"> * 借助这个特性，可以写一个编译期就能运行的函数，获取数组的大小
</span><span style="color:#080;font-style:italic"> */</span>
<span style="color:#a2f;font-weight:bold">template</span><span style="color:#666">&lt;</span><span style="color:#a2f;font-weight:bold">typename</span> T, std<span style="color:#666">::</span>size_t N<span style="color:#666">&gt;</span>
<span style="color:#a2f;font-weight:bold">constexpr</span> std<span style="color:#666">::</span>size_t arraySize(T (<span style="color:#666">&amp;</span>)[N]) <span style="color:#a2f;font-weight:bold">noexcept</span>
{
    <span style="color:#a2f;font-weight:bold">return</span> N;
}

<span style="color:#0b0;font-weight:bold">int</span> arr1[] <span style="color:#666">=</span> {<span style="color:#666">1</span>, <span style="color:#666">2</span>, <span style="color:#666">3</span>};
<span style="color:#0b0;font-weight:bold">int</span> arr2[arraySize(arr1)];
std<span style="color:#666">::</span>cout <span style="color:#666">&lt;&lt;</span> <span style="color:#a2f;font-weight:bold">sizeof</span>(arr2) <span style="color:#666">&lt;&lt;</span> std<span style="color:#666">::</span>endl; <span style="color:#080;font-style:italic">// 输出是 12
</span></code></pre></div><p>当 argument 是一个函数时，行为和数组是一样的。</p>
<h3 id="understand-auto">Understand <code>auto</code> <a href="#understand-auto" class="anchor">🔗</a></h3><h4 id="auto-and-template-type-deduction"><code>auto</code> and Template Type Deduction <a href="#auto-and-template-type-deduction" class="anchor">🔗</a></h4><p>除了一个例外，<code>auto</code> 的类型推导和模板类型推导可以直接一一映射：</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#a2f;font-weight:bold">template</span><span style="color:#666">&lt;</span><span style="color:#a2f;font-weight:bold">typename</span> T<span style="color:#666">&gt;</span>
<span style="color:#0b0;font-weight:bold">void</span> f(ParmaType param);

f(expr);
</code></pre></div><p>可以被试做一个含有 <code>auto</code> 的声明，而 <code>auto</code> 就是 <code>T</code>：</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++">ParamType param <span style="color:#666">=</span> expr;
<span style="color:#080;font-style:italic">// ParamType 中含有 auto
</span><span style="color:#080;font-style:italic"></span>
<span style="color:#080;font-style:italic">// 比如：
</span><span style="color:#080;font-style:italic"></span><span style="color:#a2f;font-weight:bold">const</span> <span style="color:#a2f;font-weight:bold">auto</span> cx <span style="color:#666">=</span> <span style="color:#666">2</span>;
<span style="color:#080;font-style:italic">// 和下面等价：
</span><span style="color:#080;font-style:italic"></span><span style="color:#a2f;font-weight:bold">template</span><span style="color:#666">&lt;</span><span style="color:#a2f;font-weight:bold">typename</span> T<span style="color:#666">&gt;</span>
<span style="color:#0b0;font-weight:bold">void</span> func_for_cx(<span style="color:#a2f;font-weight:bold">const</span> T param);

func_for_cx(<span style="color:#666">2</span>);
<span style="color:#080;font-style:italic">// param 的推导类型就是 cx 的类型
</span></code></pre></div><p>用数组和函数退化为指针的特性来举个 <code>auto</code> 的例子：</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#0b0;font-weight:bold">int</span> <span style="color:#00a000">main</span>() {
    <span style="color:#0b0;font-weight:bold">int</span> arr[] <span style="color:#666">=</span> {<span style="color:#666">1</span>, <span style="color:#666">2</span>, <span style="color:#666">3</span>};
    <span style="color:#a2f;font-weight:bold">auto</span> arr1 <span style="color:#666">=</span> arr;
    <span style="color:#a2f;font-weight:bold">auto</span> <span style="color:#666">&amp;</span> arr2 <span style="color:#666">=</span> arr;
    
    std<span style="color:#666">::</span>cout <span style="color:#666">&lt;&lt;</span> (<span style="color:#a2f;font-weight:bold">typeid</span>(arr1) <span style="color:#666">==</span> <span style="color:#a2f;font-weight:bold">typeid</span>(arr)) <span style="color:#666">&lt;&lt;</span> std<span style="color:#666">::</span>endl; <span style="color:#080;font-style:italic">// false
</span><span style="color:#080;font-style:italic"></span>    std<span style="color:#666">::</span>cout <span style="color:#666">&lt;&lt;</span> (<span style="color:#a2f;font-weight:bold">typeid</span>(arr1) <span style="color:#666">==</span> <span style="color:#a2f;font-weight:bold">typeid</span>(<span style="color:#666">&amp;</span>arr[<span style="color:#666">0</span>])) <span style="color:#666">&lt;&lt;</span> std<span style="color:#666">::</span>endl; <span style="color:#080;font-style:italic">// true
</span><span style="color:#080;font-style:italic"></span>    std<span style="color:#666">::</span>cout <span style="color:#666">&lt;&lt;</span> (<span style="color:#a2f;font-weight:bold">typeid</span>(arr2) <span style="color:#666">==</span> <span style="color:#a2f;font-weight:bold">typeid</span>(arr)) <span style="color:#666">&lt;&lt;</span> std<span style="color:#666">::</span>endl; <span style="color:#080;font-style:italic">// true
</span><span style="color:#080;font-style:italic"></span>    std<span style="color:#666">::</span>cout <span style="color:#666">&lt;&lt;</span> (<span style="color:#a2f;font-weight:bold">typeid</span>(arr2) <span style="color:#666">==</span> <span style="color:#a2f;font-weight:bold">typeid</span>(<span style="color:#666">&amp;</span>arr[<span style="color:#666">0</span>])) <span style="color:#666">&lt;&lt;</span> std<span style="color:#666">::</span>endl; <span style="color:#080;font-style:italic">// false
</span><span style="color:#080;font-style:italic"></span>}
</code></pre></div><h4 id="an-exception">An exception <a href="#an-exception" class="anchor">🔗</a></h4><p>对于 C++11 的 uniform initialization，<code>auto</code> 和 template type deduction 的行为不太一样。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#a2f;font-weight:bold">auto</span> x <span style="color:#666">=</span> {<span style="color:#666">2</span>};
std<span style="color:#666">::</span>cout <span style="color:#666">&lt;&lt;</span> <span style="color:#a2f;font-weight:bold">typeid</span>(x).name() <span style="color:#666">&lt;&lt;</span> std<span style="color:#666">::</span>endl; <span style="color:#080;font-style:italic">// output: St16initializer_listIiE
</span><span style="color:#080;font-style:italic"></span><span style="color:#0b0;font-weight:bold">int</span> y <span style="color:#666">=</span> {<span style="color:#666">2</span>};
std<span style="color:#666">::</span>cout <span style="color:#666">&lt;&lt;</span> <span style="color:#a2f;font-weight:bold">typeid</span>(y).name() <span style="color:#666">&lt;&lt;</span> std<span style="color:#666">::</span>endl; <span style="color:#080;font-style:italic">// output: i
</span></code></pre></div><p>显然 <code>x</code> 应该是个 int，但其实 <code>x</code> 是 <code>std::initializer_list&lt;int&gt;</code>，将其转化为 template type deduction 语法：</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#a2f;font-weight:bold">template</span><span style="color:#666">&lt;</span><span style="color:#a2f;font-weight:bold">typename</span> T<span style="color:#666">&gt;</span>
<span style="color:#0b0;font-weight:bold">void</span> f(T param) {
    std<span style="color:#666">::</span>cout <span style="color:#666">&lt;&lt;</span> <span style="color:#a2f;font-weight:bold">typeid</span>(param).name() <span style="color:#666">&lt;&lt;</span> std<span style="color:#666">::</span>endl;
}

f({<span style="color:#666">2</span>});
</code></pre></div><p>上面这段代码是直接编译报错的，因为模板类型推导不知道怎么处理 <code>std::initializer_list</code> 的 argument，这就是唯一的区别：<code>auto</code> 会把花括号初始化视作 <code>std::initializer_list</code>。</p>
    </div>

    
        <div class="tags">
            
                <a href="https://zhujunhui.com/tags/c&#43;&#43;">C&#43;&#43;</a>
            
        </div>
    
    
    

</section>


    </main>
    
    <footer id="footer">
    
        <div id="social">


    <a class="symbol" href="https://github.com/n1ujunhui" rel="me" target="_blank">
        
        <svg fill="#bbbbbb" width="28" height="28"  viewBox="0 0 72 72" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    
    <title>Github</title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Social-Icons---Rounded-Black" transform="translate(-264.000000, -939.000000)">
            <g id="Github" transform="translate(264.000000, 939.000000)">
                <path d="M8,72 L64,72 C68.418278,72 72,68.418278 72,64 L72,8 C72,3.581722 68.418278,-8.11624501e-16 64,0 L8,0 C3.581722,8.11624501e-16 -5.41083001e-16,3.581722 0,8 L0,64 C5.41083001e-16,68.418278 3.581722,72 8,72 Z" id="Rounded" fill="#bbbbbb"></path>
                <path d="M35.9985,13 C22.746,13 12,23.7870921 12,37.096644 C12,47.7406712 18.876,56.7718301 28.4145,59.9584121 C29.6145,60.1797862 30.0525,59.4358488 30.0525,58.7973276 C30.0525,58.2250681 30.0315,56.7100863 30.0195,54.6996482 C23.343,56.1558981 21.9345,51.4693938 21.9345,51.4693938 C20.844,48.6864054 19.2705,47.9454799 19.2705,47.9454799 C17.091,46.4500754 19.4355,46.4801943 19.4355,46.4801943 C21.843,46.6503662 23.1105,48.9634994 23.1105,48.9634994 C25.2525,52.6455377 28.728,51.5823398 30.096,50.9649018 C30.3135,49.4077535 30.9345,48.3460615 31.62,47.7436831 C26.2905,47.1352808 20.688,45.0691228 20.688,35.8361671 C20.688,33.2052792 21.6225,31.0547881 23.1585,29.3696344 C22.911,28.7597262 22.0875,26.3110578 23.3925,22.9934585 C23.3925,22.9934585 25.4085,22.3459017 29.9925,25.4632101 C31.908,24.9285993 33.96,24.6620468 36.0015,24.6515052 C38.04,24.6620468 40.0935,24.9285993 42.0105,25.4632101 C46.5915,22.3459017 48.603,22.9934585 48.603,22.9934585 C49.9125,26.3110578 49.089,28.7597262 48.8415,29.3696344 C50.3805,31.0547881 51.309,33.2052792 51.309,35.8361671 C51.309,45.0917119 45.6975,47.1292571 40.3515,47.7256117 C41.2125,48.4695491 41.9805,49.9393525 41.9805,52.1877301 C41.9805,55.4089489 41.9505,58.0067059 41.9505,58.7973276 C41.9505,59.4418726 42.3825,60.1918338 43.6005,59.9554002 C53.13,56.7627944 60,47.7376593 60,37.096644 C60,23.7870921 49.254,13 35.9985,13" fill="#FFFFFF"></path>
            </g>
        </g>
    </g>
</svg>
    </a>

    <a class="symbol" href="https://twitter.com/niujunhui" rel="me" target="_blank">
        
        <svg fill="#bbbbbb" width="28" height="28" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 width="438.536px" height="438.536px" viewBox="0 0 438.536 438.536" style="enable-background:new 0 0 438.536 438.536;"
	 xml:space="preserve">
<g>
	<path d="M414.41,24.123C398.333,8.042,378.963,0,356.315,0H82.228C59.58,0,40.21,8.042,24.126,24.123
		C8.045,40.207,0.003,59.576,0.003,82.225v274.084c0,22.647,8.042,42.018,24.123,58.102c16.084,16.084,35.454,24.126,58.102,24.126
		h274.084c22.648,0,42.018-8.042,58.095-24.126c16.084-16.084,24.126-35.454,24.126-58.102V82.225
		C438.532,59.576,430.49,40.204,414.41,24.123z M335.471,168.735c0.191,1.713,0.288,4.278,0.288,7.71
		c0,15.989-2.334,32.025-6.995,48.104c-4.661,16.087-11.8,31.504-21.416,46.254c-9.606,14.749-21.074,27.791-34.396,39.115
		c-13.325,11.32-29.311,20.365-47.968,27.117c-18.648,6.762-38.637,10.143-59.953,10.143c-33.116,0-63.76-8.952-91.931-26.836
		c4.568,0.568,9.329,0.855,14.275,0.855c27.6,0,52.439-8.565,74.519-25.7c-12.941-0.185-24.506-4.179-34.688-11.991
		c-10.185-7.803-17.273-17.699-21.271-29.691c4.947,0.76,8.658,1.137,11.132,1.137c4.187,0,9.042-0.76,14.56-2.279
		c-13.894-2.669-25.598-9.562-35.115-20.697c-9.519-11.136-14.277-23.84-14.277-38.114v-0.571
		c10.085,4.755,19.602,7.229,28.549,7.422c-17.321-11.613-25.981-28.265-25.981-49.963c0-10.66,2.758-20.747,8.278-30.264
		c15.035,18.464,33.311,33.213,54.816,44.252c21.507,11.038,44.54,17.227,69.092,18.558c-0.95-3.616-1.427-8.186-1.427-13.704
		c0-16.562,5.853-30.692,17.56-42.399c11.703-11.706,25.837-17.561,42.394-17.561c17.515,0,32.079,6.283,43.688,18.846
		c13.134-2.474,25.892-7.33,38.26-14.56c-4.757,14.652-13.613,25.788-26.55,33.402c12.368-1.716,23.88-4.95,34.537-9.708
		C357.458,149.793,347.462,160.166,335.471,168.735z"/>
</g>
</svg>

    </a>


</div>

    

    <div class="copyright">
    
       © Copyright 
       2022 
       <span class="split">
        <svg fill="#bbbbbb" width="15" height="15" version="1.1" id="heart-15" xmlns="http://www.w3.org/2000/svg" width="15px" height="15px" viewBox="0 0 15 15">
  <path d="M13.91,6.75c-1.17,2.25-4.3,5.31-6.07,6.94c-0.1903,0.1718-0.4797,0.1718-0.67,0C5.39,12.06,2.26,9,1.09,6.75&#xA;&#x9;C-1.48,1.8,5-1.5,7.5,3.45C10-1.5,16.48,1.8,13.91,6.75z"/>
</svg>
       </span>
       Junhui Zhu
    
    </div>

    
      <div class="powerby">
        Powered by <a href='http://www.gohugo.io/'>Hugo</a> Theme By <a href='https://github.com/nodejh/hugo-theme-mini'>nodejh</a>
      </div>
    
</footer>



  </body>
</html>
