<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>橘子屋</title>
    <link>https://zhujunhui.com/</link>
    <description>Recent content on 橘子屋</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>zhu</copyright>
    <lastBuildDate>Mon, 23 Aug 2021 19:04:48 +0800</lastBuildDate><atom:link href="https://zhujunhui.com/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>6.824 lab1 踩坑</title>
      <link>https://zhujunhui.com/posts/6.824-lab1/</link>
      <pubDate>Mon, 23 Aug 2021 19:04:48 +0800</pubDate>
      
      <guid>https://zhujunhui.com/posts/6.824-lab1/</guid>
      <description>上周就一边写着一边破烂的 Go 做完了，但是过不了 crash test ，今天重新写了一遍，简化了流程和复杂性（同时减少了一定的并行性）。
首先测试脚本有一个 bug ，在 src/main/test-mr.sh 的 202 行：
1wait -n 把 -n 去掉，不然在 macOS 下这是一条非法的脚本指令。会导致脚本继续往下走，直接运行后面的 sort （但此时需要 sort 的文件还没生成）最后导致 FAIL 。可能是 macOS 的问题，也可能是 zsh 的问题，反正修改之后我就顺利的 All PASS 了。
起初，我是想着 map 和 reduce 的 task 轨迹是完全并行的。换句话说，就是可以同时有 map task 和 reduce task 同时跑着，后来发现一没必要二让 master 的逻辑大大增加。于是简化为：
 master 将整个过程分为 mapPhase 和 reducePhase ，在 map 阶段还有 map 任务没完成之前，master 不会去分配 reduce 任务； 只用一把大锁锁住整个 master 对 task 的分配过程； worker 不用向 master 注册，只需要询问要任务就可以了； master 只需要根据当前的状态（map 阶段还是 reduce 阶段）回应 worker 的 request 就好，如果此时没有相应的任务了（所有任务都是完成或者进行阶段），就让 worker 等一等。  而比较麻烦的东西是 intermediate 文件的原子操作。举个例子，一个 reduce task 需要涉及到 nMap 个 intermediate 文件，而如果有多个 worker 同时在跑这个 reduce task ，这会产生一些并发问题，经过简化后是这样解决的：</description>
    </item>
    
    <item>
      <title>Notes of MapReduce</title>
      <link>https://zhujunhui.com/posts/mapreduce/</link>
      <pubDate>Tue, 10 Aug 2021 16:53:13 +0800</pubDate>
      
      <guid>https://zhujunhui.com/posts/mapreduce/</guid>
      <description>简言之，MapReduce 是一种 programming model，用于处理并产生大数据。
Map 和 Reduce 整个计算过程需要的输入是一个 KV 集合，输出也是一个 KV 集合。暴露给用户的两个 interface 是 Map 和 Reduce。
 Map 接收一个 KV 作为输入，输出一个 KV 集合，集合被称为 intermediate KV pairs ； MapReduce library 从 intermediate 数据中将相同的 key 的 values 整合成一个集合后传递给 Reduce ； Reduce 从 intermediate KV paris 中接收某个特定的 key 和这个 key 对应的一个 value 集合，将其处理之后输出一个新的 value 集合。  类似于这样：
1map: &amp;lt;k1,v1&amp;gt; -&amp;gt; list(&amp;lt;k2,v2&amp;gt;) 2reduce: &amp;lt;k2,list(v2)&amp;gt; -&amp;gt; list(v2) 其中，Reduce 的输出域和 intermediate 数据的域是相同的，和 Map 的输入域可以不同。
Google 的 MapReduce Implementation 不同的 environment 对应于不同的 implementation ，谷歌使用的计算 environment 为：</description>
    </item>
    
    <item>
      <title>6.S081 Notes</title>
      <link>https://zhujunhui.com/posts/6.s081/</link>
      <pubDate>Thu, 15 Jul 2021 15:51:07 +0800</pubDate>
      
      <guid>https://zhujunhui.com/posts/6.s081/</guid>
      <description>因为其实一直都没有好好读过 OSTEP，所以我在最近一周一口气把这本书读完了，但还是感觉不够，因为我知道要学会这玩意必须要 make hands dirty。于是准备快速的把 6.S081 过完，然后把 lab 做掉，再配合读 xv6 的代码。
System call Syscall system call 第一个 lab 没什么好记录的，只不过用 system call 小打小闹而已，从第二个 lab 开始才是真的对 kernel 做事情。
遇到的一些疑问   英语太垃，看不懂这句话：
 Add a sys_trace() function in kernel/sysproc.c that implements the new system call by remembering its argument in a new variable in the proc structure (see kernel/proc.h). The functions to retrieve system call arguments from user space are in kernel/syscall.c, and you can see examples of their use in kernel/sysproc.</description>
    </item>
    
    <item>
      <title>One Night in Beijing</title>
      <link>https://zhujunhui.com/posts/one-night-in-beijing/</link>
      <pubDate>Mon, 28 Jun 2021 14:54:53 +0800</pubDate>
      
      <guid>https://zhujunhui.com/posts/one-night-in-beijing/</guid>
      <description>2021年6月28日，距离入职还有一天，我好想橘子。
北京和上海好像，全是高楼大厦，甚是失望。今天晚上想去第五大道看看，看看还仅存的一些老北京风貌。</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://zhujunhui.com/about/</link>
      <pubDate>Sat, 26 Jun 2021 00:36:05 +0800</pubDate>
      
      <guid>https://zhujunhui.com/about/</guid>
      <description>小镇做题家，正在努力摆脱做题的思维。</description>
    </item>
    
    <item>
      <title>CSAPP Chapter 10</title>
      <link>https://zhujunhui.com/posts/csapp-c10/</link>
      <pubDate>Wed, 12 May 2021 16:45:57 +0800</pubDate>
      
      <guid>https://zhujunhui.com/posts/csapp-c10/</guid>
      <description>RIO without buffer 1ssize_t rio_readn(int fd, void *usrbuf, size_t n); 和 Unix IO 的 read 函数的区别：
 被中断打断可以重新读  成功时返回 0， 遇到 EOF 时同样返回差值。
1ssize_t rio_writen(int fd, void *usrbuf, size_t n);  被中断打断可以重新写 失败时返回 -1  RIO Input with buffer  void rio_readinitb(rio_t *rp, int fd);  将文件描述符 fd 与 读缓冲区 rp 绑定
1#define RIO_BUFSIZE 8192 2typedef struct { 3 int rio_fd; 4 int rio_cnt;	/* 应用级缓冲中未被使用的字节数 */ 5 char *rio_bufptr;	/* 下一个未被读取的字节地址 */ 6 char rio_buf[RIO_BUFSIZE];	/* buffer */ 7} rio_t; 8 9void rio_readinitb(rio_t *rp, int fd) { 10 rp-&amp;gt;rio_fd = fd; 11 rp-&amp;gt;rio_cnt = 0; 12 rp-&amp;gt;rio_bufptr = rp-&amp;gt;rio_buf; 13}  辅助函数：static ssize_t rio_read(rio_t *rp, char *usrbuf, size_t n);  对于应用程序来说，rio_read 和 Unix IO 提供的 read 的语义是一样的。</description>
    </item>
    
    <item>
      <title>One Record</title>
      <link>https://zhujunhui.com/posts/one-record/</link>
      <pubDate>Wed, 12 May 2021 16:45:57 +0800</pubDate>
      
      <guid>https://zhujunhui.com/posts/one-record/</guid>
      <description>仅记录。</description>
    </item>
    
    <item>
      <title>JDASP</title>
      <link>https://zhujunhui.com/posts/jdasp/</link>
      <pubDate>Thu, 22 Apr 2021 20:20:19 +0800</pubDate>
      
      <guid>https://zhujunhui.com/posts/jdasp/</guid>
      <description>建议 JD 学子转美本，已 run to SG。
  </description>
    </item>
    
  </channel>
</rss>
