---
title: "6.824 lab1 踩坑"
date: 2021-08-23T19:04:48+08:00
draft: true
---

上周就一边写着一边破烂的 Go 做完了，但是过不了 crash test ，今天重新写了一遍，简化了流程和复杂性（同时减少了一定的并行性）。

首先测试脚本有一个 bug ，在 `src/main/test-mr.sh` 的 202 行：

```bash
wait -n
```

把 `-n` 去掉，不然在 macOS 下这是一条非法的脚本指令。会导致脚本继续往下走，直接运行后面的 `sort` （但此时需要 `sort` 的文件还没生成）最后导致 FAIL 。可能是 macOS 的问题，也可能是 zsh 的问题，反正修改之后我就顺利的 All PASS 了。

起初，我是想着 map 和 reduce 的 task 轨迹是完全并行的。换句话说，就是可以同时有 map task 和 reduce task 同时跑着，后来发现一没必要二让 master 的逻辑大大增加。于是简化为：

- master 将整个过程分为 mapPhase 和 reducePhase ，在 map 阶段还有 map 任务没完成之前，master 不会去分配 reduce 任务；
- 只用一把大锁锁住整个 master 对 task 的分配过程；
- worker 不用向 master 注册，只需要询问要任务就可以了；
- master 只需要根据当前的状态（map 阶段还是 reduce 阶段）回应 worker 的 request 就好，如果此时没有相应的任务了（所有任务都是完成或者进行阶段），就让 worker 等一等。

而比较麻烦的东西是 intermediate 文件的**原子操作**。举个例子，一个 reduce task 需要涉及到 `nMap` 个 intermediate 文件，而如果有多个 worker 同时在跑这个 reduce task ，这会产生一些并发问题，经过简化后是这样解决的：

1. 对于多个 worker 同时跑同一个 map task 时，首先对于 raw data 的读是不会产生竞争的，随意同时读；
2. 上一个情况中，每个 worker 都先创建一个**不会有命名冲突**的 tmp 文件，在完成创建之后再将其重命名为标准的中间文件名，这样就不会产生对同一个文件的 write race 了，而且即使发生了两次重命名，也不影响整个任务的正确执行，顶多有点浪费资源；
3. 同样的，多个 worker 同时跑同一个 reduce task 时，对于 intermediate 文件的并发读没有问题；
4. 产生最终的 `mr-out-X` 之前，也遵循 2 中说的策略，先写到永远不会冲突的 tmp 文件后重命名即可。

我用的是 `os.Getpid()` 作为临时文件的后缀名，这样不同的进程就不会产生冲突了。

值得优化的地方是，我完全没有用到 Golang 引以为豪的 channel ，而且我也不太明白这个到底有什么用。。。既然过了就开始看 Raft 了。
